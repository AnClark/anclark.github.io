<!DOCTYPE html>
<html lang="zh_CN" >
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta name="description" content="">
	<meta name="keywords" content="">
	<title>页面 - 归档 - 爱拼安小匠的技术博客</title>
    <link rel="alternate" href="" type="application/atom+xml"/>
	<link rel="shortcut icon" href=""/>
	
<link rel="stylesheet" href="/css/style.css">

	
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
	<div class="main-con">

        <div class="nav cl">
    <ul class="cl nav-list">
        <!-- Customizable nav bar -->
        
            
            <li>
                
                    <a href="/" class="">
                        <i class="fa fa-home"></i> 
                        <span>主页</span>
                    </a>
                
            </li>
            
        
            
            <li>
                
                    <a href="/archives/" class="active">
                        <i class=" fa-"></i> 
                        <span>归档</span>
                    </a>
                
            </li>
            
        
            
            <li>
                
                    
                    <a href="javascript:void(0)" class="">
                    
                        <i class=" fa-"></i> 
                        <span>关于</span>
                        <span class="drop-flag fa fa-angle-down"></span>
                    </a>
                    <dl>
                        
                            <li>
                                <a href="/about" class="">
                                    <i class=" fa-"></i>
                                    <span>关于本站</span>
                                </a>
                            </li>
                        
                    </dl>
                
            </li>
            
        
            
            <!-- Language switcher -->

    <li>
        <a href="javascript:void(0)">
            <i class="fa fa-language"></i> 
            
            <span>简体中文</span>
            
            <span class="drop-flag fa fa-angle-down"></span>
        </a>
        <dl>
            
                <li>
                    
                    <a href="/" class="">
                    
                        <i class="fa fa-circle"></i>
                        <span>简体中文</span>
                    </a>
                </li>
            
                <li>
                    
                    <a href="/en/" class="">
                    
                        <i class="fa fa-circle"></i>
                        <span>English</span>
                    </a>
                </li>
            
        </dl>
    </li>

            
        
    </ul>

    <ul class="cl nav-tool">
        
            <li>
                <a href="/github">
                    <i class="fa fa-github"></i>
                </a>
            </li>
        
            <li>
                <a href="/mail">
                    <i class="fa fa-envelope"></i>
                </a>
            </li>
        
            <li>
                <a href="/twitter">
                    <i class="fa fa-twitter"></i>
                </a>
            </li>
        
        
        <li>
            <a href="javascript:void(0)" class="nav-search-btn">
                <i class="fa fa-search"></i>
            </a>
        </li>
        
    </ul>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="nav-search"><input type="search" name="q" class="nav-search-input" placeholder="search..."><input type="hidden" name="sitesearch" value="https://anclark.github.io"></form>
</div>

        <header class="top" id="fallEle" style="background-image: url(/imgs/head.jpg)">
    <i class="fa fa-bars" id="media-toggle" style="display: none"></i>
    <div class="top-info cl fadeToBottom">
        <h2 class="site-name">
            <a href="/">
                
                    爱拼安小匠的技术博客
                
            </a>
            <small id="type-data">
                
                    
                
            </small>
        </h2>
    </div>
</header>

        
<div class="con-wrap fadeToTop archive">
    
    <section class="article-area">
    
        
        
            
                <div class="archive-year"><span class="year-block">2018</span></div>

            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/09/11/Android_Adapting_Note/OmniROM：解决“zconf-hash-c--No-such-file-or-directory”/" title="OmniROM：解决“zconf.hash.c No such file or directory”错误">
                    OmniROM：解决“zconf.hash.c No such file or directory”错误
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-09-11
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Android/">Android</a></li>
                            
                        
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>编译OmniROM 8.1，到达编译内核这一步时出错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">scripts/kconfig/zconf.tab.c:206:10: fatal error: zconf.hash.c: No such file or directory<br> #include &quot;zconf.hash.c&quot;<br>          ^~~~~~~~~~~~~~<br>compilation terminated.<br></code></pre></td></tr></table></figure>
        </div>
        
            
                <a href="/2018/09/11/Android_Adapting_Note/OmniROM：解决“zconf-hash-c--No-such-file-or-directory”/" class="more-link">阅读更多...</a>
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/09/10/Android_Adapting_Note/OmniROM：“Flex-checkpolicy”出错/" title="OmniROM：解决“Flex checkpolicy”出错故障">
                    OmniROM：解决“Flex checkpolicy”出错故障
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-09-10
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Android/">Android</a></li>
                            
                        
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>编译OmniROM 8.1时，在这个地方出错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[ 21% 2441/11398] //external/selinux/checkpolicy:checkpolicy lex policy_scan.l [linux]<br>FAILED: /home/anclark/Wonderland/aosp3/omni8/out/soong/.intermediates/external/selinux/checkpolicy/checkpolicy/linux_x86_64/gen/lex/external/selinux/checkpolicy/policy_scan.c <br>prebuilts/misc/linux-x86/flex/flex-2.5.39 -o/home/anclark/Wonderland/aosp3/omni8/out/soong/.intermediates/external/selinux/checkpolicy/checkpolicy/linux_x86_64/gen/lex/external/selinux/checkpolicy/policy_scan.c external/selinux/checkpolicy/policy_scan.l<br>flex-2.5.39: loadlocale.c:130: _nl_intern_locale_data: Assertion `cnt &lt; (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))&#x27; failed.<br>Aborted (core dumped)<br></code></pre></td></tr></table></figure>
        </div>
        
            
                <a href="/2018/09/10/Android_Adapting_Note/OmniROM：“Flex-checkpolicy”出错/" class="more-link">阅读更多...</a>
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/09/10/Android_Adapting_Note/OmniROM：包含并自动同步TWRP/" title="OmniROM：包含并自动同步TWRP">
                    OmniROM：包含并自动同步TWRP
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-09-10
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Android/">Android</a></li>
                            
                        
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>知名第三方Recovery TWRP与OmniROM合作，将其最新的代码托管到OmniROM的仓库中（<a target="_blank" rel="noopener" href="https://github.com/omnirom/android_bootable_recovery%EF%BC%89%E3%80%82%E4%B8%8D%E8%BF%87%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BD%BF%E7%94%A8%60repo">https://github.com/omnirom/android_bootable_recovery）。不过默认情况下，使用`repo</a> init<code>初始化OmniROM manifest的时候，TWRP并未被包含进去，实际下载到的</code>bootable/recovery`是AOSP的版本。</p>
<p>一种解决思路是手动<code>git clone</code>TWRP的源码，不过由于它未被包含进manifest中，因此下次运行<code>repo sync</code>时，它所在的目录会被覆盖，得不偿失。</p>
<p>正确的办法是，更改OmniROM的manifest文件，在其中包含TWRP。</p>
        </div>
        
            
                <a href="/2018/09/10/Android_Adapting_Note/OmniROM：包含并自动同步TWRP/" class="more-link">阅读更多...</a>
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/09/07/Mend_My_Computer/踩坑：固态硬盘连接故障使系统假死崩溃/" title="踩坑：固态硬盘连接故障使系统假死崩溃">
                    踩坑：固态硬盘连接故障使系统假死崩溃
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-09-07
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/电脑维修/">电脑维修</a></li>
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>笔者的惠普Pavilion笔记本使用的是双硬盘：原装1TB西部数据机械硬盘，配上光驱位的ADATA SP550 240GB固态硬盘。EFI分区、Windows 10+Ubuntu 18.04双系统及其应用软件安装在固态硬盘上，机械硬盘在删除系统有关的分区后专门用来存放数据。如此一来，速度存储两不误，重新定义了我对Windows和电脑速度的认识。</p>
<p>相对稳定运行两年有余，然而，就在昨天（2018年9月6日），意想不到的情况发生了。</p>
        </div>
        
            
                <a href="/2018/09/07/Mend_My_Computer/踩坑：固态硬盘连接故障使系统假死崩溃/" class="more-link">阅读更多...</a>
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/09/05/Use_Python/使用PyAudio模块播放音频流之体会/" title="使用PyAudio模块播放音频流之体会">
                    使用PyAudio模块播放音频流之体会
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-09-05
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Python/">Python</a></li>
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>PyAudio是Python下的一个音频处理模块，用于将音频流输送到计算机声卡上。理论上，该模块能够播放任何解码器解码而成的有效音频帧。</p>
        </div>
        
            
                <a href="/2018/09/05/Use_Python/使用PyAudio模块播放音频流之体会/" class="more-link">阅读更多...</a>
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/09/04/Android_Adapting_Note/使用Visual-Studio-Code阅读Android内核源码/" title="使用Visual Studio Code阅读Android内核源码">
                    使用Visual Studio Code阅读Android内核源码
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-09-04
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Android/">Android</a></li>
                            
                        
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>Visual Studio Code是阅读代码的不二选择，尤其是与传统IDE工程并驾齐驱的、由构建器（Make、Ninja、CMake等）组织的工程，只需打开一个文件夹作为工作区，即可立刻开始。而VS Code对C语言的多方面支持，使得用它来阅读、学习、调试C语言源代码，尤有一种舒心简便的体验。</p>
<p>——所以，对于学习Linux Android内核源码的程序员，我首先推荐VS Code。只需简单的配置，就可以将VS Code打造成贴心的Linux代码阅读工具。</p>
        </div>
        
            
                <a href="/2018/09/04/Android_Adapting_Note/使用Visual-Studio-Code阅读Android内核源码/" class="more-link">阅读更多...</a>
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/09/04/Struggle_with_Linux/经验体会：解决Ubuntu-18-04+Windows双系统时间不同步的问题/" title="经验体会：解决Ubuntu 18.04 + Windows双系统时间不同步的问题">
                    经验体会：解决Ubuntu 18.04 + Windows双系统时间不同步的问题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-09-04
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Linux/">Linux</a></li>
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>Ubuntu和Windows双系统，开发娱乐两不误，随用随切换，岂不美哉？</p>
<p>然而，在美的背后，存在一个让人抓狂的Bug：从一个系统切换到另一个系统后，时间就会出错，表现为——</p>
<p><strong>时差8小时。</strong></p>
<p>例如：</p>
<ul>
<li>Ubuntu中时间正常，但是切换回Windows后，后者的时间慢8个小时。</li>
<li>Windows中时间正常，但是切换回Ubuntu后，后者的时间快8个小时。</li>
</ul>
<p>一个系统中时间错乱，尚可通过互联网时间同步（NTP服务器）来解决。但是切换到另一个系统后，时差问题照样如故。</p>
        </div>
        
            
                <a href="/2018/09/04/Struggle_with_Linux/经验体会：解决Ubuntu-18-04+Windows双系统时间不同步的问题/" class="more-link">阅读更多...</a>
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/09/02/Paper/Adapt_Android_Oreo_to_Huawei_P6/" title="拯救老旗舰：为华为Ascend P6适配Android 8.1">
                    拯救老旗舰：为华为Ascend P6适配Android 8.1
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-09-02
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/论文报告/">论文报告</a></li>
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这是一篇未完成的实验报告，因为在写报告之时，笔者的实验并没有成功，后续还有很多工作需要完成。而笔者所做的项目在之前几乎没有任何可参考的先例，只有适合于其他设备方案的资料参照，可谓“摸着石头过河”。在毕业论文截止之际，笔者先将截至2018年9月初所得到的研究成果记录下来，暂且作为本次毕业论文的内容。</p>
<p>华为Ascend P6（以下简称P6），是华为于2013年推出的一款旗舰手机，属<strong>P系列</strong>旗舰的第六款，也是华为海思（<em>HiSillicon</em>）处理器应用的里程碑，具有重要的战略和纪念意义。然而，就是这样一款里程碑旗舰，却一直被广大Android开发者忽视，以至于推出5年多，都没有开发者为其适配历代最新的Android系统[^Ref_HD2]。</p>
<p>而Android系统的适配，本身更是一项需要大量精力投入的工作，涉及到配置文件的收集、编写，长期多方面的调试，以及潜在问题的跟踪，其中的调试环节更是需要细致耐心，因为在一款完全没有运行对应版本Android系统的设备上，随时都会出现连原厂开发者均难以发现的问题。</p>
<p>笔者愿意为这项漫长的工作而付出，这不仅是因为P6在国产芯片发展史上的重大实践意义，也是为了以此来锻炼自己的科研能力。这些工作最终的意义，于Android开发者界，于笔者本人，都是有意义的。</p>
<blockquote>
<p> <strong>注：</strong>正文部分关于shell的代码块，若将命令和输出放在一起，则命令前加上提示符<code>$</code>，否则不加。</p>
</blockquote>
<h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h2><h3 id="（1）华为Ascend-P6"><a href="#（1）华为Ascend-P6" class="headerlink" title="（1）华为Ascend P6"></a>（1）华为Ascend P6</h3><p>华为Ascend P6是华为P系列旗舰家族的成员，于2013年推出。它是华为首款搭载海思处理器的旗舰机，在华为乃至国产手机芯片的发展史上拥有里程碑的重要意义。配置如下所示：</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>配置情况</th>
</tr>
</thead>
<tbody><tr>
<td>型号与网络</td>
<td>P6-T00：移动版，支持TD-SCDMA、GSM<br>P6-C00：电信版，支持CDMA、GSM<br>P6-U06：联通版，支持WCDMA、GSM</td>
</tr>
<tr>
<td>CPU</td>
<td>HiSillicon K3V2</td>
</tr>
<tr>
<td>架构</td>
<td>ARM Cortex-a7 32位</td>
</tr>
<tr>
<td>RAM</td>
<td>2.0GB LPDDR3</td>
</tr>
<tr>
<td>ROM</td>
<td>16GB eMMC</td>
</tr>
<tr>
<td>屏幕</td>
<td>4.8英寸LCD 1280x720</td>
</tr>
<tr>
<td>操作系统</td>
<td>预装 Android 4.2.2，采用华为EMUI 2.0界面<br>官方可更新至Android 4.4（EMUI 3.0）[^stopped_support]</td>
</tr>
<tr>
<td>内核版本</td>
<td>Linux 3.0.8</td>
</tr>
<tr>
<td>移动网络</td>
<td>支持三大运营商3G、2G网络（运营商定制型号，非全网通）<br>双卡，副卡只支持GSM</td>
</tr>
<tr>
<td>无线通信</td>
<td>WLAN、蓝牙</td>
</tr>
</tbody></table>
<p>笔者所持有的P6为电信版本<strong>P6-C00</strong>。</p>
<h3 id="（2）Android系统开放性及其弊端"><a href="#（2）Android系统开放性及其弊端" class="headerlink" title="（2）Android系统开放性及其弊端"></a>（2）Android系统开放性及其弊端</h3><p>Android是谷歌推出的一款开放源代码的移动操作系统，遵循Apache 2.0协议。任何开发者，包括厂商和个人开发者，均可从Android系统的官方网站（source.android.com [^android_website_in_China]）获取源代码。它与生俱来的这一开放性，使得大量的开发者在其基础上开发了各种定制版本，真正将其“为我所用”。2018年，最新的正式版是Android 8.1 Oreo。</p>
<p>现阶段，Android系统的定制版本分为两大方向：</p>
<p>一是厂商进行定制，发布到自家的产品上，我们能购买到的设备产品（如手机、平板电脑、智能手表等）所搭载的Android系统均属于该类型。这里的定制，不仅仅包括在Android官方源代码的基础上进行功能的定制，还包括各种二次开发。最著名的例子就是小米的MIUI、华为的EMUI、魅族的Flyme OS，以及锤子科技的Smartisan OS。一般而言，厂商多不会将自己的定制系统进行开源，这就意味着只有官方的设备才能使用，并获得长期的技术支持。</p>
<p>二是定制后保持开源。这样的Android定制版本多在原生Android的基础上做出一些功能上的改进，推出新功能，从而成为更具易用性的系统。它们延续Android官方源代码的策略，继续保持开源，这使得广大开发者可以适配出适合于自己设备的Android系统。著名的有魔趣（MoKee）、LineageOS、OmniROM、ResurrectionRemix等。</p>
<p>然而，Android系统的开放性，造成了一个不可忽视的弊端，即碎片化。在开放性的背景下，Android系统版本的升级由厂商负责，而不是谷歌官方，但并不是所有的厂商都能及时响应Android版本的更新，从而导致一个新版本Android系统推出后，仍有大量的设备在使用旧版本的系统，一些设备最新的系统版本甚至定格在了4.4以下版本，甚至古老的2.3。如此现状导致了双重后果：安全性掉队（谷歌每推出一个Android更新，都会带来大量的安全性改进），以及用户体验落后。</p>
<p>本报告中的目标设备P6，就是一个典型的例子。官方在推出它的第二年后，就放弃了对其系统更新的支持，这使得它能使用的最新Android版本永远地定格在了4.4。即使2016年Android 6.0推出，2017年Android 7.0推出，官方也不为所动。如此态度，对于一款昔日的旗舰，着实不公。</p>
<h2 id="二、正式适配计划与准备"><a href="#二、正式适配计划与准备" class="headerlink" title="二、正式适配计划与准备"></a>二、正式适配计划与准备</h2><h3 id="（一）笔者的工作环境"><a href="#（一）笔者的工作环境" class="headerlink" title="（一）笔者的工作环境"></a>（一）笔者的工作环境</h3><p>笔者计划为P6适配的系统为Android 8.1 Oreo，选用开源定制版本OmniROM。在Android开源定制版本中，OmniROM技术成熟，适配过程相对简便，特选择之。用于编译适配的计算机为笔者的惠普Pavilion笔记本，操作系统为Ubuntu 18.04 64-bit。</p>
<p><strong>计算机已配置好编译环境，并下载了源代码</strong>。</p>
<p>笔者计算机的配置如下：</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>配置情况</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>型号</td>
<td>HP Pavilion Notebook</td>
<td>惠普畅游人笔记本电脑，购买于2015年</td>
</tr>
<tr>
<td>CPU</td>
<td>Intel Core i7-5500U 2.40GHz（睿频≈2.85Ghz）</td>
<td>第五代酷睿i7处理器，低压移动版</td>
</tr>
<tr>
<td>GPU</td>
<td>Intel HD Graphics<br>NVidia Geforce 940M</td>
<td>双显卡，但在Linux中只能使用核显</td>
</tr>
<tr>
<td>内存</td>
<td>8GB LPDDR3</td>
<td></td>
</tr>
<tr>
<td>固态硬盘</td>
<td>ADATA SP550 240GB</td>
<td>操作系统与虚拟内存安装于固态硬盘上</td>
</tr>
<tr>
<td>机械硬盘</td>
<td>WD 1TB 5400转</td>
<td>Android源代码搭载于机械硬盘上</td>
</tr>
<tr>
<td>操作系统</td>
<td>Ubuntu 18.04 LTS 64-bit</td>
<td></td>
</tr>
</tbody></table>
<h3 id="（二）准备设备配置文件"><a href="#（二）准备设备配置文件" class="headerlink" title="（二）准备设备配置文件"></a>（二）准备设备配置文件</h3><p>Android是一个与具体硬件密切相关的系统。要想使系统在具体的设备上运行，必须要准备好合适的配置文件，以此为编译系统的依据。对于P6，需要准备以下配置文件：</p>
<table>
<thead>
<tr>
<th>配置文件</th>
<th>Android源码的目标路径</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>设备参数文件</td>
<td><code>device/huawei/hwp6_u06</code></td>
<td>配置文件的核心，用以在Android源码中声明设备，并指定构建系统所需的一系列参数</td>
</tr>
<tr>
<td>内核源代码</td>
<td><code>kernel/huawei/hwp6_u06</code></td>
<td>Linux内核的源代码，是运行Android的基石</td>
</tr>
<tr>
<td>厂商配置文件</td>
<td><code>vendor/huawei</code></td>
<td>存放厂商提供的专有文件，设备正常运行必需</td>
</tr>
</tbody></table>
<p>Android目标设备的多样性，使得编写配置文件需要庞大的工作量。幸运的是，在此前，GitHub上有开发者已经做好了第三方Android的适配，因此可以在其中找到现成的配置文件。依次以<code>device huawei p6</code>、<code>kernel huawei p6</code>与<code>vendor huawei p6</code>为关键字搜索即可。</p>
<p>笔者选用了以下配置文件：</p>
<ul>
<li>设备参数文件（由marlintoe提供）：<a target="_blank" rel="noopener" href="https://github.com/marlontoe/device_huawei_hwp6_u06.git">https://github.com/marlontoe/device_huawei_hwp6_u06.git</a></li>
<li>内核源代码（由surdupetru提供）：<a target="_blank" rel="noopener" href="https://github.com/surdupetru/huawei-p6.git">https://github.com/surdupetru/huawei-p6.git</a></li>
<li>厂商配置文件（由marlintoe提供）</li>
</ul>
<h3 id="（三）设备配置文件介绍"><a href="#（三）设备配置文件介绍" class="headerlink" title="（三）设备配置文件介绍"></a>（三）设备配置文件介绍</h3><p>值得注意的是，以上设备配置文件并非“开箱即用”的，在将这些文件复制到对应位置后，并不能马上开始编译。这是因为上述作者编写的配置文件仅适用于旧版本的OmniROM，具体为Android 4.4。然而时过境迁，新版本的Android编译系统与原先4.4时期有很大不同，并且原作者在编写时并未考虑到将来出现的Android系统版本。若直接使用这些基于旧版本的配置文件进行编译，则必定会出现各种错误。</p>
<p>为了让这些配置文件能够适应笔者拥有的新版本编译系统，须根据新版本源码和设备的具体情况，对原始配置文件进行修改。以下简要介绍配置文件的构成，后续会涉及到修改的过程。</p>
<h4 id="1-设备参数文件"><a href="#1-设备参数文件" class="headerlink" title="1. 设备参数文件"></a>1. 设备参数文件</h4><p>P6的设备参数文件（<code>device/huawei/hwp6_u06</code>）核心构成如下表所示（只列出最基本的文件）。其中<code>.mk</code>后缀的是Makefile文件，<code>.sh</code>为Shell脚本：</p>
<table>
<thead>
<tr>
<th>文件名/目录名<br><small>（结尾带“<code>/</code>”的为目录）</small></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>Android.mk</code></td>
<td>入口文件，编译系统包含（include）它，以将设备参数文件纳入编译系统中</td>
</tr>
<tr>
<td><code>AndroidProducts.mk</code></td>
<td>设备参数文件的核心，编译系统会在读取参数文件时先读取它<br>该文件会自动包含<code>omni_hwp6_u06.mk</code>与<code>full_hwp6_u06.mk</code></td>
</tr>
<tr>
<td><code>AndroidBoard.mk</code></td>
<td>类似于<code>AndroidProducts.mk</code>，让编译系统包含一些附加的编译目标（如预编译的内核）。这里不需要。</td>
</tr>
<tr>
<td><code>BoardConfig.mk</code></td>
<td>以<code>&lt;变量名&gt; := &lt;值&gt;</code>的格式，集中设定各种与设备特性有关的参数，以及一些组件的位置（如内核源码路径、内核配置文件名）</td>
</tr>
<tr>
<td><code>omni_hwp6_u06.mk</code></td>
<td>OmniROM配置的入口，在其中定义了设备的基本信息。是OmniROM编译系统识别一套设备参数文件不可或缺的依据。</td>
</tr>
<tr>
<td><code>device_hwp6_u06.mk</code></td>
<td><code>omni_hwp6_u06.mk</code>的补充，被其包含，用于列出预编译好的、需要复制到系统中的文件</td>
</tr>
<tr>
<td><code>full_hwp6_u06.mk</code></td>
<td>AOSP配置的入口，从谷歌原生的Android源码承继而来，用不到。</td>
</tr>
<tr>
<td><code>overlay/</code></td>
<td>叠加层文件，定义对Android自带系统程序（如“设置”）界面的调整，如添加/删除设置项、调整布局</td>
</tr>
<tr>
<td><code>prebuilt/</code></td>
<td>存放预编译好的、需要安装于设备中的文件</td>
</tr>
<tr>
<td><code>recovery/</code></td>
<td>需要放置于Recovery根文件系统（rootfs）的额外文件，通常是厂商专用的文件</td>
</tr>
<tr>
<td><code>root/</code></td>
<td>需要放置于根文件系统（rootfs）的额外文件，通常是厂商专用的文件</td>
</tr>
<tr>
<td><code>sepolicy/</code></td>
<td>存放设备专用的SELinux策略文件</td>
</tr>
<tr>
<td><code>vendorsetup.sh</code></td>
<td>将当前设备的编译目标添加到编译系统中，添加后用户可在编译系统中选择编译该设备<br>会被编译系统的初始化脚本<code>build/envsetup.sh</code>自动包含</td>
</tr>
</tbody></table>
<h4 id="2-内核源代码"><a href="#2-内核源代码" class="headerlink" title="2. 内核源代码"></a>2. 内核源代码</h4><p>P6的内核源代码存放于<code>kernel/huawei/hwp6_u06</code>，文件构成与一般的Linux内核源码一致。区别仅在于：</p>
<ul>
<li>内核源码根目录中有一个<code>Android.mk</code>作为入口文件，指定编译内核的一系列Makefile规则。</li>
<li>内核源码架构目录<code>arch/arm/configs</code>下有P6专用的配置文件<code>cm_k3v2oem1_defconfig</code>。</li>
</ul>
<h4 id="3-构建变量和产品变量"><a href="#3-构建变量和产品变量" class="headerlink" title="3. 构建变量和产品变量"></a>3. 构建变量和产品变量</h4><p>用户在编译时可以通过指定构建变量（build variable），来选择编译Android系统的类型。不同编译类型面向不同类型的用户，它们的区别在于对调试功能的开放程度。可选的构建变量如下：</p>
<table>
<thead>
<tr>
<th>构建变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>release</code></td>
<td>正式版本，供最终用户使用。我们购买的手机、平板电脑等设备即属于此类型。它默认禁用了各种调试功能，旨在提供一个稳定的系统</td>
</tr>
<tr>
<td><code>userdebug</code></td>
<td>调试版本，是用户自行编译源码的一般选择。提供一些基本的调试功能，如默认打开ADB、允许禁用SELinux</td>
</tr>
<tr>
<td><code>eng</code></td>
<td>工程版本，由厂商使用。在<code>userdebug</code>的基础上提供了更多的调试选项，开放程度为三者之最，但更不适合最终用户使用</td>
</tr>
</tbody></table>
<p>面对日益纷繁复杂的Android源码，从Android 7.0起，谷歌开发了一套全新的编译系统Soong，旨在改善构建Android系统的体验。在Soong体系中，引入了一个新的概念——产品变量（product variable），从产品的视角来看待编译选项的设置。它的本质与构建变量相同，只是将<code>userdebug</code>与<code>eng</code>归为<code>debuggable</code>。但亦允许用户在专用的配置文件<code>Android.bp</code>中，于<code>debuggable</code>基础上再为这两种构建变量指定专用的参数。</p>
<h2 id="三、可行性测试：为P6编译TWRP-Recovery-3-1-0-0"><a href="#三、可行性测试：为P6编译TWRP-Recovery-3-1-0-0" class="headerlink" title="三、可行性测试：为P6编译TWRP Recovery 3.1.0.0"></a>三、可行性测试：为P6编译TWRP Recovery 3.1.0.0</h2><p>确定一台设备有没有适配新系统的可能性，最优的起步点即为为该设备编译一个TWRP Recovery。Recovery是Android系统的恢复环境，支持在设备上进行刷机与基于系统底层的管理；TWRP则是一款专业的触屏Recovery环境。TWRP能正常运行，就说明接下来的努力就有了实现的空间，手上的这台P6自然能焕发第二春。本质上，TWRP Recovery是一个特制的<strong>启动映像（boot image）</strong>，文件结构包括文件头（含内核启动参数）、Linux内核、RAMdisk与DTB（Device Tree Binary，编译成二进制的设备树。华为P6不需要），其中的RAMdisk包含了TWRP的主程序和运行环境。它的结构与Android本身的启动镜像完全相同，因此在正式测试Android系统的启动过程之前，可以以TWRP作为参照。</p>
<h3 id="（一）准备工作"><a href="#（一）准备工作" class="headerlink" title="（一）准备工作"></a>（一）准备工作</h3><p>删除OmniROM自带的谷歌官方Recovery环境，位于<code>bootable/recovery</code>。然后用<code>git</code>，将TWRP的源码下载到这个目录中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/omnirom/android_bootable_recovery.git bootable/recovery -b android-8.1<br></code></pre></td></tr></table></figure>

<h3 id="（二）修改设备参数文件"><a href="#（二）修改设备参数文件" class="headerlink" title="（二）修改设备参数文件"></a>（二）修改设备参数文件</h3><p>设备参数文件目录<code>device/huawei/hwp6_u06</code>中的<code>BoardConfig.mk</code>中记录了设备相关的参数，TWRP编译时所使用的参数也列于其中。</p>
<p>编译前，确保下面的参数设置正确：</p>
<ul>
<li><p><code>TW_THEME</code></p>
<ul>
<li>TWRP必填参数，设定Recovery所用的主题。根据设备分辨率和屏幕方向的不同，可选的值为<code>landscape_hdpi</code>、<code>landscape_mdpi </code>、<code>portrait_hdpi </code>、<code>portrait_mdpi</code>、<code>watch_mdpi  </code>。华为P6选用<code>portrait_hdpi</code>。</li>
</ul>
</li>
<li><p><code>TARGET_KERNEL_SOURCE</code></p>
<ul>
<li>内核源码所在位置。设置为<code>kernel/huawei/hwp6_u06</code>。</li>
</ul>
</li>
<li><p><code>TARGET_KERNEL_CONFIG</code></p>
<ul>
<li>内核配置文件，指定编译内核的参数。华为P6选用<code>cm_k3v2oem1_defconfig</code>。</li>
</ul>
</li>
<li><p>启动镜像的参数</p>
<ul>
<li><p>启动镜像的参数因设备而异，原作者已经配置好。这些参数如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 内核命令参数</span><br>BOARD_KERNEL_CMDLINE := vmalloc=512M k3v2_pmem=1 mmcparts=mmcblk0:p1(xloader),p3(nvme),p4(misc),p5(splash),p6(oeminfo),p7(reserved1),p8(reserved2),p9(splash2),p10(recovery2),p11(recovery),p12(boot),p13(modemimage),p14(modemnvm1),p15(modemnvm2),p16(system),p17(cache),p18(cust),p19(userdata);mmcblk1:p1(ext_sdcard)<br><span class="hljs-comment"># 内核偏移</span><br>BOARD_KERNEL_BASE := 0x00000000<br><span class="hljs-comment"># 内核的页大小</span><br>BOARD_KERNEL_PAGESIZE := 2048<br><span class="hljs-comment"># 启动映像生成工具（mkbootimg）传入的参数</span><br><span class="hljs-comment"># 指定的--ramdisk-offset为RAMDisk在映像文件中的偏移</span><br>BOARD_MKBOOTIMG_ARGS += --ramdisk_offset 0x01400000<br><span class="hljs-comment"># 内核文件名。文件名决定了内核被压缩而成的格式</span><br>BOARD_KERNEL_IMAGE_NAME := zImage<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>禁用以下选项[^how_to_disable_them]，否则会导致编译出的Recovery出现问题：</p>
<ul>
<li><code>×TARGET_PREBUILT_KERNEL</code><ul>
<li>使用预编译的内核而不是从源码编译。原作者已经提供了一个内核，本用于编译旧版本Android 4.4系统与2.x系列的TWRP，但笔者实验证明，旧内核缺少新版本Android所必需的功能，导致Recovery无法启动。这一点会在后面的实验中证明。</li>
</ul>
</li>
<li><code>×TARGET_PREBUILT_RECOVERY_KERNEL</code><ul>
<li>编译Recovery时使用预编译的内核而不是从源码编译。原因同上。</li>
</ul>
</li>
<li><code>×TARGET_RECOVERY_INITRC</code><ul>
<li>使用用户提供的<code>init.rc</code>。<code>init.rc</code>是Android初始化程序<code>init</code>解析的主脚本，使用Android初始化语言（Android init language）编写，指定了系统启动时需要执行的一些工作。原作者编写了一个<code>init.rc</code>文件，位于<code>device/huawei/hwp6_u06/recovery/init.rc</code>，但是该文件是为旧版本Android编写的，其中的很多配置与新版本的Android系统不兼容；且其中混合了Recovery启动时必需的代码与设备特定的代码，前者已由TWRP配备，直接照搬原作者提供的文件必会导致冲突。</li>
</ul>
</li>
</ul>
<h3 id="（三）修改内核源码Android-mk文件"><a href="#（三）修改内核源码Android-mk文件" class="headerlink" title="（三）修改内核源码Android.mk文件"></a>（三）修改内核源码<code>Android.mk</code>文件</h3><p>Android编译系统中的<code>Android.mk</code>，是每一个编译目标的入口文件，包含目标编译所需的规则。编译系统通过扫描并包含这些文件，来得出Android系统的编译目标。对于内核，若要在编译系统时一并编译内核源码以得到一个新内核，则须在内核源码目录中编写<code>Android.mk</code>。</p>
<p>原作者提供的内核源码中已经包含了<code>Android.mk</code>，但是它也是为旧版本Android系统编写的，其中的编译规则并不适用于Android 8.1，甚至还会使Android 8.1的编译系统报错。因此必须修改。</p>
<p>以下的<code>diff</code>补丁显示了笔者修改的内容，其中用一连串<code>#</code>号包围的行作为修改说明，遵循Makefile的语法规则。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/Android.mk b/Android.mk</span><br><span class="hljs-comment">index 7749b4229..5e854161f 100644</span><br><span class="hljs-comment">--- a/Android.mk</span><br><span class="hljs-comment">+++ b/Android.mk</span><br><span class="hljs-meta">@@ -7,28 +7,29 @@</span> KERNEL_CONFIG := $(KERNEL_OUT)/.config<br> TARGET_PREBUILT_KERNEL := $(KERNEL_OUT)/arch/arm/boot/zImage<br> <br> KERNEL_ARCH_ARM_CONFIGS := kernel/arch/arm/configs<br> #####################################<br> #  删除自动生成配置文件的规则（1/3）<br> #  这里指定让内核编译系统使用自动生成的配置文件，而不是事先编写好的<br> #  华为海思官方的内核有自动生成内核配置文件的脚本，但实际上并未提供相关工具<br> #  并且配置文件已经事先编写完成，不需再重新生成<br> #####################################<br><span class="hljs-deletion">-KERNEL_GEN_CONFIG_FILE := huawei_k3v2oem1_$(HW_PRODUCT)_defconfig</span><br><span class="hljs-deletion">-KERNEL_GEN_CONFIG_PATH := $(KERNEL_ARCH_ARM_CONFIGS)/$(KERNEL_GEN_CONFIG_FILE)</span><br><span class="hljs-addition">+#KERNEL_GEN_CONFIG_FILE := huawei_k3v2oem1_$(HW_PRODUCT)_defconfig</span><br><span class="hljs-addition">+#KERNEL_GEN_CONFIG_PATH := $(KERNEL_ARCH_ARM_CONFIGS)/$(KERNEL_GEN_CONFIG_FILE)</span><br> <br> #####################################<br> #  不要使用华为设备参数文件中提供的配置文件<br> #  华为海思有专门的设备参数文件，位于`device/hisi`，但用于研发环境<br> #  本论文不需要研发环境的配置，加之所需的内核配置文件已位于内核源码中，故删除之<br> #####################################<br> KERNEL_COMMON_DEFCONFIG := $(KERNEL_ARCH_ARM_CONFIGS)/$(KERNEL_DEFCONFIG)<br><span class="hljs-deletion">-KERNEL_PRODUCT_CONFIGS  := device/hisi/k3v2oem1/product_spec/kernel_config/$(HW_PRODUCT)</span><br><span class="hljs-addition">+#KERNEL_PRODUCT_CONFIGS  := device/hisi/k3v2oem1/product_spec/kernel_config/$(HW_PRODUCT)</span><br> KERNEL_DEBUG_CONFIGS := $(KERNEL_ARCH_ARM_CONFIGS)/debug<br> <br> #####################################<br> #  删除自动生成驱动程序代码的规则<br> #  从下面代码得知，华为海思的一些专用驱动程序疑为使用XML编写，并通过下面的脚本<br> #  转换为用于编译的源代码。属研发环境的范畴<br> #  本论文不需要研发环境的配置，加之所需的驱动程序已位于内核源码中，故删除之<br> #####################################<br><span class="hljs-deletion">-$(shell cd device/hisi/customize/hsad;./xml2complete.sh &gt; /dev/null)</span><br><span class="hljs-deletion">-$(shell cd kernel/drivers/huawei/hsad;./xml2code.sh)</span><br><span class="hljs-addition">+#$(shell cd device/hisi/customize/hsad;./xml2complete.sh &gt; /dev/null)</span><br><span class="hljs-addition">+#$(shell cd kernel/drivers/huawei/hsad;./xml2code.sh)</span><br> <br> #add debug-kernel-config file generation rules by z00175161<br> ifeq ($(TARGET_BUILD_TYPE),release)<br>   KERNEL_DEBUG_CONFIGFILE := $(KERNEL_COMMON_DEFCONFIG)<br>   <br> $(KERNEL_DEBUG_CONFIGFILE):FORCE<br><span class="hljs-deletion">-	echo &quot;do nothing&quot;  </span><br><span class="hljs-addition">+	echo &quot;do nothing. Configuration is already provided by Surdupetru&quot;  </span><br> <br> else<br>   KERNEL_DEBUG_CONFIGFILE :=  $(KERNEL_ARCH_ARM_CONFIGS)/huawei_k3v2oem1_$(HW_PRODUCT)_debug_defconfig<br>   <br> #####################################<br> #  删除自动生成配置文件的规则（2/3）<br> #  华为海思官方的内核有自动生成内核配置文件的脚本，但实际上并未提供相关工具<br> #  并且配置文件已经事先编写完成，不需再重新生成<br> #  因此直接将其忽略，代之以笔者自定义的消息提示<br> #####################################<br> $(KERNEL_DEBUG_CONFIGFILE):FORCE<br><span class="hljs-deletion">-	$(shell device/hisi/k3v2oem1/kernel-config.sh -f $(KERNEL_COMMON_DEFCONFIG) -d $(KERNEL_DEBUG_CONFIGS) -o $(KERNEL_DEBUG_CONFIGFILE))</span><br><span class="hljs-addition">+	#$(shell device/hisi/k3v2oem1/kernel-config.sh -f $(KERNEL_COMMON_DEFCONFIG) -d $(KERNEL_DEBUG_CONFIGS) -o $(KERNEL_DEBUG_CONFIGFILE))</span><br><span class="hljs-addition">+	echo &quot;do nothing. Configuration is already provided by Surdupetru. No need to generate again.&quot;</span><br> endif<br> <br> ifeq ($(KERNEL_DEBUG_CONFIGFILE),$(KERNEL_COMMON_DEFCONFIG))<br><span class="hljs-meta">@@ -42,7 +43,8 @@</span> $(KERNEL_OUT):<br> 	mkdir -p $(KERNEL_OUT)<br> <br> #####################################<br> #  删除自动生成配置文件的规则（3/3）<br> #  华为海思官方的内核有自动生成内核配置文件的脚本，但实际上并未提供相关工具<br> #  并且配置文件已经事先编写完成，不需再重新生成<br> #  因此直接将其忽略，代之以笔者自定义的消息提示<br> #####################################<br> $(KERNEL_GEN_CONFIG_PATH): $(KERNEL_DEBUG_CONFIGFILE)<br><span class="hljs-deletion">-	$(shell device/hisi/k3v2oem1/kernel-config.sh -f $(KERNEL_DEBUG_CONFIGFILE) -d $(KERNEL_PRODUCT_CONFIGS) -o $(KERNEL_GEN_CONFIG_PATH))</span><br><span class="hljs-addition">+	#$(shell device/hisi/k3v2oem1/kernel-config.sh -f $(KERNEL_DEBUG_CONFIGFILE) -d $(KERNEL_PRODUCT_CONFIGS) -o $(KERNEL_GEN_CONFIG_PATH))</span><br><span class="hljs-addition">+	echo &quot;do nothing. Configuration is already provided by Surdupetru. No need to generate again.&quot;</span><br> <br> $(KERNEL_CONFIG): $(KERNEL_OUT) $(KERNEL_GEN_CONFIG_PATH)<br> 	$(MAKE) -C kernel O=../$(KERNEL_OUT) ARCH=arm CROSS_COMPILE=arm-linux-androideabi- $(KERNEL_GEN_CONFIG_FILE)<br><span class="hljs-meta">@@ -50,9 +52,9 @@</span> $(KERNEL_CONFIG): $(KERNEL_OUT) $(KERNEL_GEN_CONFIG_PATH)<br> 	@rm -frv $(KERNEL_TOBECLEAN_CONFIGFILE)<br> <br> #####################################<br> #  删除使用预编译内核的规则<br> #  预编译好的内核与新版本系统不兼容，不能使用。必须修改源代码后重新编译<br> #####################################<br><span class="hljs-deletion">-$(TARGET_PREBUILT_KERNEL): $(KERNEL_CONFIG)</span><br><span class="hljs-deletion">-	$(hide) $(MAKE) -C kernel O=../$(KERNEL_OUT) ARCH=arm CROSS_COMPILE=arm-linux-androideabi- -j 18</span><br><span class="hljs-deletion">-	$(hide) $(MAKE) -C kernel O=../$(KERNEL_OUT) ARCH=arm CROSS_COMPILE=arm-linux-androideabi- -j 18 zImage</span><br><span class="hljs-addition">+#$(TARGET_PREBUILT_KERNEL): $(KERNEL_CONFIG)</span><br><span class="hljs-addition">+#	$(hide) $(MAKE) -C kernel O=../$(KERNEL_OUT) ARCH=arm CROSS_COMPILE=arm-linux-androideabi- -j 18</span><br><span class="hljs-addition">+#	$(hide) $(MAKE) -C kernel O=../$(KERNEL_OUT) ARCH=arm CROSS_COMPILE=arm-linux-androideabi- -j 18 zImage</span><br> <br> kernelconfig: $(KERNEL_OUT) $(KERNEL_GEN_CONFIG_PATH)<br> 	$(MAKE) -C kernel O=../$(KERNEL_OUT) ARCH=arm CROSS_COMPILE=arm-linux-androideabi- $(KERNEL_GEN_CONFIG_FILE) menuconfig<br></code></pre></td></tr></table></figure>

<h3 id="（四）-尝试编译并刷入Recovery启动映像"><a href="#（四）-尝试编译并刷入Recovery启动映像" class="headerlink" title="（四） 尝试编译并刷入Recovery启动映像"></a>（四） 尝试编译并刷入Recovery启动映像</h3><p>以上准备工作完成后，笔者尝试编译Recovery映像，并将其刷入设备中尝试启动。</p>
<p>Android的启动映像存储于<code>boot</code>和<code>recovery</code>两个分区中，前者用于启动Android系统，后者则存放Recovery映像。为调试方便，笔者将“ATX”团队的一款ClockworkMod Recovery做了精简（下文简称“ATX”），刷入<code>boot</code>分区中，让手机正常启动时能够进入该款Recovery中[^why_prune]。但是，实际使用时，由于精简过度，进入ATX后手机黑屏不能操作，只能连接电脑使用ADB（Android Debug Bridge）管理手机。精简后只保留Busybox与<code>adbd</code>（Android Debug Bridge Daemon）功能，用于连接电脑进行调试。</p>
<p>回到OmniROM源码根目录，依次运行以下命令开始编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">source build/envsetup.sh			# 初始化编译环境<br>lunch omni_hwp6_u06-userdebug		# 指定编译目标为华为P6<br>make recoveryimage					# 开始编译Recovery映像<br></code></pre></td></tr></table></figure>

<p>编译输出的结果在<code>out/target/product/hwp6_u06</code>中，其中生成的Recovery映像文件名为<code>recovery.img</code>。需要进入设备的引导模式（bootloader），并使用Android官方的刷机工具<code>fastboot</code>进行刷入。将设备打开电源，连接电脑，正常进入ATX ，并在终端中运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb reboot bootloader				# 重启手机进入Bootloader模式<br>fastboot flash recovery out/target/product/hwp6_u06/recovery.img	# 刷入Recovery<br>fastboot reboot						# 正常重启手机<br>adb reboot recovery					# 进入ATX后，再重启手机，进入Recovery模式<br></code></pre></td></tr></table></figure>

<p>从ATX进入Bootloader模式的标志是屏幕短暂黑屏，随后长时间定格在开机第一屏上；而从Bootloader模式重启回到ATX模式的标志，则是在显示开机画面一段时间后屏幕关闭。可靠起见，使用下面两个命令判断设备是否与电脑正确连接，若连接成功则会输出设备的ID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb devices							# 检查ATX模式与电脑的连接情况<br>fastboot devices					# 检查Bootloader模式与电脑的连接情况<br></code></pre></td></tr></table></figure>

<h3 id="（五）问题一：开机画面反复循环"><a href="#（五）问题一：开机画面反复循环" class="headerlink" title="（五）问题一：开机画面反复循环"></a>（五）问题一：开机画面反复循环</h3><p>进入Recovery模式之后，机器一直未进入Recovery，而是显示开机画面一段时间后，立即黑屏重启，再度显示开机画面，又再度重启，如此不断循环。而强制按电源键重启后，又能正常回到ATX模式。笔者怀疑，问题就集中在刚编译的Recovery映像上。</p>
<p>根据启动映像制作工具<code>mkbootimg</code>的源码说明（位于<code>system/core/mkbootimg/bootimg.h</code>），启动映像由以下四个部分组成：</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>说明</th>
<th>占用页数</th>
</tr>
</thead>
<tbody><tr>
<td>boot header</td>
<td>启动映像的文件头</td>
<td>1</td>
</tr>
<tr>
<td>kernel</td>
<td>Linux内核映像</td>
<td>n</td>
</tr>
<tr>
<td>ramdisk</td>
<td>启动内存盘镜像</td>
<td>m</td>
</tr>
<tr>
<td>second stage</td>
<td>第二阶段部分，即附加的部分（如DTB）</td>
<td>o</td>
</tr>
</tbody></table>
<p>页数以字节为单位，海思K3V2平台指定为<code>2048</code>。三个量n、m、o之间的关系如下：</p>
<ul>
<li><code>n = (kernel_size + page_size - 1) / page_size</code></li>
<li><code>m = (ramdisk_size + page_size - 1) / page_size</code></li>
<li><code>o = (second_size + page_size - 1) / page_size</code></li>
</ul>
<p>K3V2平台不需要second stage，因此问题只能出现在剩下的三个部分中，笔者计划从第一个部分boot header开始检验。boot header由启动映像制作工具<code>mkbootimg</code>生成，不同的工具可能会生成不同的header，因此笔者决定，用若干个相关工具对Recovery映像进行重新打包，再刷入测试。</p>
<p>用于测试的工具如下所示（假设这些工具均已位于<code>$PATH</code>中）：</p>
<ul>
<li><p><code>bootimg.py</code></p>
<ul>
<li>由中国开发者Liu DongMiao（<a href="mailto:&#108;&#105;&#x75;&#100;&#x6f;&#x6e;&#x67;&#109;&#x69;&#97;&#x6f;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;">&#108;&#105;&#x75;&#100;&#x6f;&#x6e;&#x67;&#109;&#x69;&#97;&#x6f;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a>）开发，使用Python 2.7编写，支持快速解包/打包启动映像。默认存储文件名固定，可以不需指定额外参数</li>
</ul>
</li>
<li><p>Android官方提供的<code>mkbootimg</code>工具</p>
<ul>
<li><p>源码位于Android源码目录的<code>system/core/mkbootimg</code>中</p>
</li>
<li><p>选用下列Android源码所附带的版本。其中除Omni 8.1自带者用Python编写外，其余均用C语言编写：</p>
<ul>
<li>Omni 4.3</li>
<li>Omni 4.4</li>
<li>Omni 6.0</li>
<li>Omni 8.1</li>
</ul>
</li>
<li><p>对于C语言编写者，在所在目录下用以下命令进行编译。编译所得的文件名加上与Android版本对应的后缀，如<code>mkbootimg-4.3</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc mkbootimg.c ../libmincrypt/sha.c -I../include -o mkbootimg<br>gcc unpackbootimg.c ../libmincrypt/sha.c -I../include -o unpackbootimg<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>测试的具体步骤如下：</p>
<ol>
<li><p>将<code>recoveryimage.img</code>移动到<code>/tmp/recimg_modify</code>目录中，重命名为<code>boot.img</code>。这是<code>bootimg.py</code>的要求。</p>
</li>
<li><p>进入<code>/tmp/recimg_modify</code>，使用<code>bootimg.py</code>进行解包。解包过程会输出<code>boot.img</code>的一些信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> bootimg.py --unpack-bootimg</span><br>arguments: [bootimg file]<br>bootimg file: boot.img<br>output: kernel[.gz] ramdisk[.gz] second[.gz]<br>kernel_addr=0x8000<br>ramdisk_addr=0x1400000<br>second_addr=0xf00000<br>tags_addr=0x100<br>page_size=2048<br>name=&quot;&quot;<br>cmdline=&quot;vmalloc=512M k3v2_pmem=1 mmcparts=mmcblk0:p1(xloader),p3(nvme),p4(misc),p5(splash),p6(oeminfo),p7(reserved1),p8(reserved2),p9(splash2),p10(recovery2),p11(recovery),p12(boot),p13(modemimage),p14(modemnvm1),p15(modemnvm2),p16(system),p17(cache),p18(cust),p19(userdata);mmcblk1:p1(ext_sdcard) buildvariant=userdebug&quot;<br>padding_size=2048<br></code></pre></td></tr></table></figure>

<p>解包后，得到<code>kernel</code>、<code>ramdisk.gz</code>和<code>bootimg.json</code>三个文件。其中<code>bootimg.json</code>记录了启动镜像的参数。</p>
</li>
<li><p>使用<code>bootimg.py</code>回打包。由于回打包会覆盖原始文件<code>boot.img</code>，故需将原始文件改名为<code>boot-old.img</code>，然后再运行打包命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bootimg.py --repack-bootimg<br></code></pre></td></tr></table></figure></li>
<li><p>使用<code>mkbootimg-6.0</code>回打包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkbootimg-6.0 \<br>--kernel kernel --ramdisk ramdisk.gz \<br>--cmdline &quot;vmalloc=512M k3v2_pmem=1 mmcparts=mmcblk0:p1(xloader),p3(nvme),p4(misc),p5(splash),p6(oeminfo),p7(reserved1),p8(reserved2),p9(splash2),p10(recovery2),p11(recovery),p12(boot),p13(modemimage),p14(modemnvm1),p15(modemnvm2),p16(system),p17(cache),p18(cust),p19(userdata);mmcblk1:p1(ext_sdcard) buildvariant=userdebug&quot; \<br>--base 0x0000 --ramdisk_offset 0x1400000 --kernel_offset 0x8000 --pagesize 2048 \<br>-o bootimg-6.0.img<br></code></pre></td></tr></table></figure></li>
<li><p>依次再使用<code>mkbootimg-4.4</code>、<code>mkbootimg-4.3</code>和<code>mkbootimg-8.1</code>打包。命令行与<code>mkbootimg-6.0</code>相同，只是程序名和输出文件名表示系统版本的后缀要作相应修改，最终得到<code>bootimg-4.4.img</code>与<code>bootimg-4.3.img</code>。</p>
</li>
<li><p>最后依次将上述步骤所得到的启动映像刷入设备中，一一进行测试，并记录结果。</p>
</li>
</ol>
<p>测试的结果如下所示：</p>
<table>
<thead>
<tr>
<th>映像文件名</th>
<th>生成工具</th>
<th>启动结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>boot.img</code></td>
<td><code>bootimg.py</code></td>
<td>不再开机画面无限重启</td>
</tr>
<tr>
<td><code>bootimg-6.0.img</code></td>
<td><code>mkbootimg-6.0</code></td>
<td>仍然无限重启</td>
</tr>
<tr>
<td><code>bootimg-4.4.img</code></td>
<td><code>mkbootimg-4.4</code></td>
<td>仍然无限重启</td>
</tr>
<tr>
<td><code>bootimg-4.3.img</code></td>
<td><code>mkbootimg-4.3</code></td>
<td>不再开机画面无限重启</td>
</tr>
<tr>
<td><code>bootimg-8.1.img</code></td>
<td><code>mkbootimg-8.1</code></td>
<td>不再开机画面无限重启</td>
</tr>
</tbody></table>
<p>理论上，上述所有工具均使用同样的<code>kernel</code>与<code>ramdisk</code>进行打包，最终所得映像的相应部分会完全相同。而不同的地方，则正在于除此之外的部分，亦即boot header。使用十六进制比较工具（如Beyond Compare、<code>hexdiff</code>）对比能启动的映像文件和不能启动的映像文件，可以发现文件头有明显的不同，表现为并不是所有的字节都对齐。使用Beyond Compare比较发现，同样的字节位置，在其中一个文件里有数值，而另一个文件却为空，二者产生差异的部分观感类似于缺粒的玉米。</p>
<p>而上述差异，来自<code>mkbootimg</code>程序源码中对boot header文件头定义的不同。要弄清文件头差异的根源，还需从源代码中寻找答案。启动映像的文件头存放着该映像的元数据，它的定义位于<code>system/core/mkbootimg/bootimg.h</code>中，为结构体<code>boot_img_hdr</code>。文件头根据结构体的定义存放，每一个要素的大小即C代码中结构体元素的大小。</p>
<p>OmniROM 8.1中的<code>boot_img_hdr</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** OmniROM 8.1 **/</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span> <span class="hljs-title">boot_img_hdr</span>;</span><br><br><span class="hljs-comment">/* 宏常量 */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_MAGIC <span class="hljs-meta-string">&quot;ANDROID!&quot;</span>			<span class="hljs-comment">/* 文件标识符（magic），固定为&quot;ANDROID!&quot; */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_MAGIC_SIZE 8				<span class="hljs-comment">/* 文件标识符的大小 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_NAME_SIZE 16				<span class="hljs-comment">/* 启动名字大小 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_ARGS_SIZE 512				<span class="hljs-comment">/* 内核启动参数大小 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_EXTRA_ARGS_SIZE 1024		<span class="hljs-comment">/* 内核附加启动参数大小 */</span></span><br><br><span class="hljs-comment">/* Boot header 定义的实现 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">uint8_t</span> magic[BOOT_MAGIC_SIZE];		<span class="hljs-comment">/* 文件标识符，位于文件头部 */</span><br><br>    <span class="hljs-keyword">uint32_t</span> kernel_size;  <span class="hljs-comment">/* 内核大小，以字节为单位 */</span><br>    <span class="hljs-keyword">uint32_t</span> kernel_addr;  <span class="hljs-comment">/* 内核在启动映像中的物理地址 */</span><br><br>    <span class="hljs-keyword">uint32_t</span> ramdisk_size; <span class="hljs-comment">/* Ramdisk大小，以字节为单位 */</span><br>    <span class="hljs-keyword">uint32_t</span> ramdisk_addr; <span class="hljs-comment">/* Ramdisk在启动映像中的物理地址 */</span><br><br>    <span class="hljs-keyword">uint32_t</span> second_size;  <span class="hljs-comment">/* 第二阶段部分大小，以字节为单位 */</span><br>    <span class="hljs-keyword">uint32_t</span> second_addr;  <span class="hljs-comment">/* 第二阶段部分在启动映像中的物理地址 */</span><br><br>    <span class="hljs-keyword">uint32_t</span> tags_addr;    <span class="hljs-comment">/* 内核标记（kernel tags）的物理地址 */</span><br>    <span class="hljs-keyword">uint32_t</span> page_size;    <span class="hljs-comment">/* 分配的页面大小 */</span><br>    <span class="hljs-keyword">uint32_t</span> unused;       <span class="hljs-comment">/* 用于扩展的空间，其值必须为0 */</span><br><br>    <span class="hljs-comment">/* operating system version and security patch level; for</span><br><span class="hljs-comment">     * version &quot;A.B.C&quot; and patch level &quot;Y-M-D&quot;:</span><br><span class="hljs-comment">     * ver = A &lt;&lt; 14 | B &lt;&lt; 7 | C         (7 bits for each of A, B, C)</span><br><span class="hljs-comment">     * lvl = ((Y - 2000) &amp; 127) &lt;&lt; 4 | M  (7 bits for Y, 4 bits for M)</span><br><span class="hljs-comment">     * os_version = ver &lt;&lt; 11 | lvl */</span><br>    <span class="hljs-keyword">uint32_t</span> os_version;<br><br>    <span class="hljs-keyword">uint8_t</span> name[BOOT_NAME_SIZE]; <span class="hljs-comment">/* asciiz product name */</span><br><br>    <span class="hljs-keyword">uint8_t</span> cmdline[BOOT_ARGS_SIZE]; <span class="hljs-comment">/* 内核启动的命令行 */</span><br><br>    <span class="hljs-keyword">uint32_t</span> id[<span class="hljs-number">8</span>]; <span class="hljs-comment">/* timestamp / checksum / sha1 / etc */</span><br><br>    <span class="hljs-comment">/* Supplemental command line data; kept here to maintain</span><br><span class="hljs-comment">     * binary compatibility with older versions of mkbootimg */</span><br>    <span class="hljs-keyword">uint8_t</span> extra_cmdline[BOOT_EXTRA_ARGS_SIZE];<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure>

<p>对比旧版本OmniROM 6.0的<code>boot_img_hdr</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/** OmniROM 6.0 **/</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span> <span class="hljs-title">boot_img_hdr</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_MAGIC <span class="hljs-meta-string">&quot;ANDROID!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_MAGIC_SIZE 8</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_NAME_SIZE 16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_ARGS_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_EXTRA_ARGS_SIZE 1024</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">uint8_t</span> magic[BOOT_MAGIC_SIZE];<br><br>    <span class="hljs-keyword">uint32_t</span> kernel_size;  <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-keyword">uint32_t</span> kernel_addr;  <span class="hljs-comment">/* physical load addr */</span><br><br>    <span class="hljs-keyword">uint32_t</span> ramdisk_size; <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-keyword">uint32_t</span> ramdisk_addr; <span class="hljs-comment">/* physical load addr */</span><br><br>    <span class="hljs-keyword">uint32_t</span> second_size;  <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-keyword">uint32_t</span> second_addr;  <span class="hljs-comment">/* physical load addr */</span><br><br>    <span class="hljs-keyword">uint32_t</span> tags_addr;    <span class="hljs-comment">/* physical addr for kernel tags */</span><br>    <span class="hljs-keyword">uint32_t</span> page_size;    <span class="hljs-comment">/* flash page size we assume */</span><br>    <span class="hljs-keyword">uint32_t</span> dt_size;      <span class="hljs-comment">/* device tree in bytes */</span><br>    <span class="hljs-keyword">uint32_t</span> unused;       <span class="hljs-comment">/* future expansion: should be 0 */</span><br>    <span class="hljs-keyword">uint8_t</span> name[BOOT_NAME_SIZE]; <span class="hljs-comment">/* asciiz product name */</span><br><br>    <span class="hljs-keyword">uint8_t</span> cmdline[BOOT_ARGS_SIZE];<br><br>    <span class="hljs-keyword">uint32_t</span> id[<span class="hljs-number">8</span>]; <span class="hljs-comment">/* timestamp / checksum / sha1 / etc */</span><br><br>    <span class="hljs-comment">/* Supplemental command line data; kept here to maintain</span><br><span class="hljs-comment">     * binary compatibility with older versions of mkbootimg */</span><br>    <span class="hljs-keyword">uint8_t</span> extra_cmdline[BOOT_EXTRA_ARGS_SIZE];<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure>

<p>更老的版本OmniROM 4.3中，<code>boot_img_hdr</code>则如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/** OmniROM 4.3 **/</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span> <span class="hljs-title">boot_img_hdr</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_MAGIC <span class="hljs-meta-string">&quot;ANDROID!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_MAGIC_SIZE 8</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_NAME_SIZE 16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOT_ARGS_SIZE 512</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_img_hdr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> magic[BOOT_MAGIC_SIZE];<br><br>    <span class="hljs-keyword">unsigned</span> kernel_size;  <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-keyword">unsigned</span> kernel_addr;  <span class="hljs-comment">/* physical load addr */</span><br><br>    <span class="hljs-keyword">unsigned</span> ramdisk_size; <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-keyword">unsigned</span> ramdisk_addr; <span class="hljs-comment">/* physical load addr */</span><br><br>    <span class="hljs-keyword">unsigned</span> second_size;  <span class="hljs-comment">/* size in bytes */</span><br>    <span class="hljs-keyword">unsigned</span> second_addr;  <span class="hljs-comment">/* physical load addr */</span><br><br>    <span class="hljs-keyword">unsigned</span> tags_addr;    <span class="hljs-comment">/* physical addr for kernel tags */</span><br>    <span class="hljs-keyword">unsigned</span> page_size;    <span class="hljs-comment">/* flash page size we assume */</span><br>    <span class="hljs-keyword">unsigned</span> unused[<span class="hljs-number">2</span>];    <span class="hljs-comment">/* future expansion: should be 0 */</span><br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> name[BOOT_NAME_SIZE]; <span class="hljs-comment">/* asciiz product name */</span><br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> cmdline[BOOT_ARGS_SIZE];<br><br>    <span class="hljs-keyword">unsigned</span> id[<span class="hljs-number">8</span>]; <span class="hljs-comment">/* timestamp / checksum / sha1 / etc */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>对这三处代码进行三路比较，统一变量类型（<code>unsigned char</code>等价于<code>uint8_t</code>，<code>unsigned</code>等价于<code>uint32_t</code>）后，结果如下图。从中可知，8.1的数据结构与4.3基本一致，但是6.0相比前两者，则在<code>page_size</code>和<code>unused</code>两项之间加入了一个<code>dt_size</code>，导致三者的数据结构不对齐。</p>


<p><strong>至此可知，boot header格式不正确，会导致K3V2平台的Bootloader无法识别，从而无限重启。</strong></p>
<h3 id="（六）问题二：开机后定格在开机画面"><a href="#（六）问题二：开机后定格在开机画面" class="headerlink" title="（六）问题二：开机后定格在开机画面"></a>（六）问题二：开机后定格在开机画面</h3><p>以上能够突破”问题一“难关的两个Recovery映像，虽然因boot header正确而被Bootloader成功引导，但仍然并未成功，而是出现了第二个问题：定格在开机第一屏。</p>
<p>画面停留在开机第一屏，首先就要判断设备是否重启进入了Bootloader模式。但是，当笔者连接电脑，并使用<code>fastboot devices</code>检测连接状况时，却发现该命令没有任何输出（若有设备连接则会显示设备的ID）。这说明当前设备所处在的状态并不是Bootloader，而是卡在了Recovery的引导过程中。</p>
<p>笔者尝试用<code>adb devices</code>检测设备状态，结果<code>adb</code>亦未输出设备的ID，说明设备并未在线。而电脑端<code>adb</code>访问设备端的前提是设备端需要开启<code>adbd</code>服务（TWRP等第三方Recovery默认启用<code>adbd</code>），而<code>adbd</code>服务只有在引导进入系统后才由ramdisk中的初始化程序<code>init</code>进程启动。Linux内核加载后才启动<code>init</code>。由上述推理，显然得知，P6的引导过程卡在了Linux内核的加载过程中。</p>
<p>查清故障的首要方法即为获取内核日志，但在设备无法连接电脑的情况下，很难获取日志。华为的技术人员还可以通过串口连接电脑，对内核进行底层调试，但笔者并无此条件。</p>
<h4 id="（1）尝试之一：借助kmesg启动内核"><a href="#（1）尝试之一：借助kmesg启动内核" class="headerlink" title="（1）尝试之一：借助kmesg启动内核"></a>（1）尝试之一：借助<code>kmesg</code>启动内核</h4><p>对于诊断内核问题，笔者首先想到的思路，即为借助<code>kmesg</code>启动内核。<code>kmesg</code>是Linux官方提供的工具，允许在系统启动后的用户态环境下，如运行程序般运行一个内核。著名的Android多系统管理器MultiROM就是用该工具来实现多系统启动的。</p>
<p>可以从Linux官方网站上找到该工具的源代码（<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git%EF%BC%89%EF%BC%8C%E5%B9%B6%E7%BC%96%E8%AF%91%E6%88%90%E9%80%82%E7%94%A8%E4%BA%8EARM%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82%E7%AC%94%E8%80%85%E9%80%89%E7%94%A8Linux%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%89%88%EF%BC%88%E6%88%AA%E8%87%B32018%E5%B9%B47%E6%9C%88%EF%BC%89%E3%80%82%E7%BC%96%E8%AF%91%E5%99%A8%E5%B7%A5%E5%85%B7%E9%93%BE%E9%80%89%E6%8B%A9%60gcc-arm-linux-gnueabi%60%E7%9A%844.9%E7%89%88%E6%9C%AC%E3%80%82">https://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git），并编译成适用于ARM平台的版本。笔者选用Linux提供的最新稳定版（截至2018年7月）。编译器工具链选择`gcc-arm-linux-gnueabi`的4.9版本。</a></p>
<p>具体编译的步骤如下。这里是在X86_64平台上编译ARM平台的程序，因此为交叉编译：</p>
<ol>
<li><p>将源码克隆到<code>/tmp/kexec-tools</code>目录中，并切换到其中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git /tmp/kexec-tools<br>cd /tmp/kexec-tools<br></code></pre></td></tr></table></figure></li>
<li><p>初始化编译系统，并配置编译参数。</p>
<blockquote>
<p><big><strong>TODO：现在手上只有4.4.3的编译器！！！！</strong></big></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">./bootstrap				# 编译配置程序使用automake编写，运行该命令以生成编译环境<br><span class="hljs-meta">#</span><span class="bash"> 运行编译配置程序，其中：</span><br><span class="hljs-meta">#</span><span class="bash"> --host=arm</span><br><span class="hljs-meta">#</span><span class="bash">		交叉编译必选项，表明主机上运行所运行编译器的目标平台</span><br><span class="hljs-meta">#</span><span class="bash"> CC=arm-linux-gcc</span><br><span class="hljs-meta">#</span><span class="bash">		指定交叉编译为目标设备编译时使用的编译器。</span><br><span class="hljs-meta">#</span><span class="bash"> LDFLAGS=-static</span><br><span class="hljs-meta">#</span><span class="bash">		传递给链接器（linker）的参数，-static表示将程序编译为静态可执行文件</span><br>./configure --host=arm CC=arm-linux-gcc LDFLAGS=-static<br></code></pre></td></tr></table></figure></li>
<li><p>开始编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -j8<br></code></pre></td></tr></table></figure>

<p>编译所得的可执行文件位于子目录<code>build/sbin</code>中。<strong>必须静态编译，否则会因缺少依赖而无法在P6上独立运行。</strong></p>
</li>
<li><p>启动P6进入ATX，将<code>kexec</code>与内核传送到根目录<code>/</code>。</p>
<p>在Android编译系统中，编译好的内核位于<code>out/target/product/hwp6_u06/kernel</code>。一并将<code>kexec</code>与内核复制到<code>/tmp</code>，然后在<code>/tmp</code>中运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb push kexec /<br>adb push kernel /<br></code></pre></td></tr></table></figure></li>
<li><p> 运行测试。执行<code>adb shell</code>，连接到设备上的终端（terminal），然后尝试运行<code>kexec</code>。结果却出现了这样的错误提示：</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">FATAL: Kernel too old<br>Aborted<br></code></pre></td></tr></table></figure>

<p>查阅Quora得知，运行静态编译的可执行文件会出现这种现象，原因在于交叉编译器限制了最低内核的版本[^quora]。静态编译的可执行文件会包含运行库<code>glibc</code>，而<code>glibc</code>本身有内核版本的限制。使用<code>file</code>工具查看<code>kexec</code>的基本信息时（<code>file build/sbin/kexec</code>），可以得知该可执行文件运行时所需的最低内核版本为<code>3.2.0</code>（注意“for GNU/Linux`”处）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs null"><br></code></pre></td></tr></table></figure>

<p>解决这一问题只有两种思路：升级内核，或降低编译器版本（低版本的编译器所作的版本限制会低一些）。显然，最简便的方法即为降低编译器版本，其中包括使用<code>./configure --enable-kernel=&lt;低于3.0.8的版本号&gt;</code>重新配置并编译交叉编译器（GCC编译器本身也是有源码、可以被编译的），也包括直接使用现成的低版本编译器。编译编译器的工作比较繁琐，在有限的时间内不现实；而笔者手中正好拥有一套由FriendlyARM组织于2011年推出的<code>gcc-arm-none-linux-gnueabi 4.4.3</code>编译器。</p>
<p>因此，笔者将编译器安装到系统中，重新进行以上步骤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">make distclean					# 清理编译时产生的临时文件，避免出错<br>./bootstrap<br><span class="hljs-meta">#</span><span class="bash"> 重新运行编译配置程序，选用低版本编译器</span><br><span class="hljs-meta">#</span><span class="bash"> STRIP=arm-none-linux-gnueabi-strip</span><br><span class="hljs-meta">#</span><span class="bash">			指定目标代码裁剪器。目标代码裁剪器用于裁剪二进制文件中多余的代码，节省存储空间</span><br><span class="hljs-meta">#</span><span class="bash"> Ubuntu 18.04附带的strip工具与该低版本编译器不兼容，因此必须使用该编译器自带的strip</span><br>./configure --host=arm CC=arm-none-linux-gnueabi-gcc STRIP=arm-none-linux-gnueabi-strip LDFLAGS=-static<br>make -j8<br></code></pre></td></tr></table></figure>

<p>再次检查所生成可执行文件的信息，可以发现最低内核版本降低了不少：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">build/sbin/kexec: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, with debug_info, not stripped<br></code></pre></td></tr></table></figure>

<p>P6 ATX的内核版本亦为<code>3.0.8</code>，该版本的<code>kexec</code>已经可以正常运行了。下一步，即为尝试从ATX启动新编译的内核。运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kexec --command-line=&quot;vmalloc=512M k3v2_pmem=1 mmcparts=mmcblk0:p1(xloader),p3(nvme),p4(misc),p5(splash),p6(oeminfo),p7(reserved1),p8(reserved2),p9(splash2),p10(recovery2),p11(recovery),p12(boot),p13(modemimage),p14(modemnvm1),p15(modemnvm2),p16(system),p17(cache),p18(cust),p19(userdata);mmcblk1:p1(ext_sdcard) buildvariant=userdebug&quot; kernel<br></code></pre></td></tr></table></figure>

<p>然而，对于ARM平台，<code>kexec</code>还需一个参数，为<code>--dtb</code>，指定设备树二进制文件。事实上，设备树并不是ARM平台的必需，没有设备树，设备仍然能够启动——运行官方Android 4.2.2～4.4系统的P6正是一个典型的例证。K3V2平台的内核源码并未提供任何与设备树有关的源文件与目标文件（以<code>device*tree</code>、<code>dts</code>（device tree source）为关键字检索），因此这个<code>--dtb</code>参数无法满足。不过，尝试忽略它，<code>kexec</code>却无法继续了，仍然强制要求指定一个设备树二进制文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;贴出kexec的报错提示&gt;<br></code></pre></td></tr></table></figure>

<p><strong>至此，使用<code>kexec</code>启动内核的方法得证不适用于P6。</strong></p>
<h4 id="（2）尝试之二：更换内核编译器"><a href="#（2）尝试之二：更换内核编译器" class="headerlink" title="（2）尝试之二：更换内核编译器"></a>（2）尝试之二：更换内核编译器</h4><p>笔者编译运行<code>kexec</code>的尝试虽然失败，但尝试过程中出现的“<code>Kernel too old</code>”提示却给了我一个启发：GCC编译器版本能够影响可执行文件是否能运行，那么对于同样使用GCC编译的内核，它能否正常运行，也会与编译器有关。带着这个设想，笔者尝试亦用旧版本<code>gcc-arm-none-linux-gnueabi 4.4.3</code>编译器来编译内核。</p>
<p>具体编译与测试的步骤如下：</p>
<ol>
<li><p>切换到内核源码所在的目录下。位于Android源码目录的<code>kernel/huawei/hwp6_u06</code>。</p>
</li>
<li><p>设置编译环境相关变量。</p>
</li>
</ol>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARCH=arm                                    <span class="hljs-comment"># 目标架构</span><br>SUBARCH=arm                                 <span class="hljs-comment"># 第二目标架构</span><br>CROSS_COMPILE=arm-none-linux-gnueabi-       <span class="hljs-comment"># 交叉编译器前缀</span><br></code></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li>初始化编译环境并开始编译。</li>
</ol>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make distclean                      <span class="hljs-comment"># 清除所有临时文件</span><br>make cm_k3v2oem1_defconfig          <span class="hljs-comment"># 加载K3V2平台的配置文件</span><br>make -j8                            <span class="hljs-comment"># 开始编译</span><br></code></pre></td></tr></table></figure>

编译完成后，生成的内核镜像zImage为`arch/arm/boot/zImage`。
</code></pre>
<ol start="4">
<li>将新的内核重新打包到由<code>bootimg.py</code>解包的Recovery启动镜像中。</li>
</ol>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用`zImage`覆盖`/tmp/recimg_modify`下的`kernel`文件</span><br>cp arch/arm/boot/zImage /tmp/recimg_modify/kernel<br><br><span class="hljs-comment"># 重新打包内核</span><br><span class="hljs-built_in">cd</span> /tmp/recimg_modify<br>bootimg.py --repack-bootimg<br></code></pre></td></tr></table></figure>
</code></pre>
<ol start="5">
<li>将新的内核映像刷入设备。</li>
</ol>
<p>有别于“问题一”，测试结果发生了新的变化。设备不再卡滞于开机画面中，而是在开机画面停留一段时间后自动重启，重启后方才再度长时间定格在开机第一屏。使用<code> fastboot devices</code>检测可知，该重启进入了Bootloader模式。</p>
<p>为了排除偶然因素，笔者重现上述步骤，继续进行如下的补充实验：</p>
<ul>
<li>使用新版本GCC编译器重新编译。将<code>CROSS_COMPILE</code>的值改为<code>arm-linux-</code>。</li>
<li>再次使用<code>4.4.3</code>版本编译器编译。</li>
</ul>
<p>结果如下表所示：</p>
<table>
<thead>
<tr>
<th>补充实验</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>使用新版本编译器重新编译</td>
<td>与“问题一”的故障相同，仍然长时间卡滞于开机第一屏</td>
</tr>
<tr>
<td>再次用旧版本编译器编译</td>
<td>不再卡滞，而是重启进入Bootloader</td>
</tr>
</tbody></table>
<p><strong>至此，更换旧版本编译器的方法得证适用于P6，可以用此方法解决开机画面定格的问题。</strong>P6所使用的<code>3.0.8</code>版本内核过旧，新版本编译器可能不再兼容。</p>
<h4 id="（3）让编译系统默认使用4-4-3编译器"><a href="#（3）让编译系统默认使用4-4-3编译器" class="headerlink" title="（3）让编译系统默认使用4.4.3编译器"></a>（3）让编译系统默认使用<code>4.4.3</code>编译器</h4><p>以上实验证明，P6在编译内核上必须使用专门的编译器，而不能使用Android源码自带的版本。为此，须修改设备参数文件，使得编译系统在编译内核时，自动使用<code>4.4.3</code>版本编译器，避免每次遵照上述步骤手动编译内核的不便。</p>
<p>在<code>device/huawei/hwp6_u06</code>下新建文件夹<code>toolchain</code>，然后将整套<code>4.4.3</code>编译器置入其中。并修改<code>BoardConfig.mk</code>，加上如下参数，下次编译生效：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Use custom kernel building toolchain instead of Omni-provided one</span><br>TARGET_KERNEL_CROSS_COMPILE_PREFIX := arm-none-linux-gnueabi-<br>KERNEL_TOOLCHAIN := <span class="hljs-variable">$(ANDROID_BUILD_TOP)</span>/device/huawei/hwp6_u06/toolchain/FriendlyARM/toolschain/4.4.3/bin<br></code></pre></td></tr></table></figure>

<h3 id="（七）调试准备：了解K3V2平台的panic日志转存机制"><a href="#（七）调试准备：了解K3V2平台的panic日志转存机制" class="headerlink" title="（七）调试准备：了解K3V2平台的panic日志转存机制"></a>（七）调试准备：了解K3V2平台的panic日志转存机制</h3><p>获取Android系统的Linux内核日志，通常的做法是在系统中运行<code>dmesg</code>打印出一段时间内的日志，或<code>cat /proc/kmsg</code>实时输出日志。而在未进入Android的情况下，以上的方法就失效了，取而代之的只有获取panic日志[^unavailable_kernel_debug]。panic，是Linux开发者对内核崩溃的形象称呼。</p>
<p>幸运的是，K3V2平台提供了一个获取panic日志的有效机制——<code>APANIC_MMC</code>：在发生崩溃时，将panic日志转存到存储器的某一个分区中。用户只需使用<code>cat</code>命令读取该分区的内容即可。该机制是Android内核崩溃记录机制<code>APANIC</code>的延伸，作为一个驱动程序加载。</p>
<p>内核配置文件中的以下参数用于控制<code>APANIC_MMC</code>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>CONFIG_APANIC</code></td>
<td>布尔值</td>
<td>启用/关闭Android内核崩溃记录机制</td>
</tr>
<tr>
<td><code>CONFIG_ANDROID_RAM_CONSOLE</code></td>
<td>布尔值</td>
<td>启用/关闭Android内存控制台<br><small>该功能可能也为<code>APANIC</code>提供支持，笔者不能证明二者相关性，但仍然启用</small></td>
</tr>
<tr>
<td><code>CONFIG_APANIC_MMC</code></td>
<td>布尔值</td>
<td>启用/关闭崩溃日志转存至存储器</td>
</tr>
<tr>
<td><code>CONFIG_APANIC_PLABEL</code></td>
<td>字符串</td>
<td>设置转存崩溃日志的目标分区名字<br>这里的名字是对分区的命名，而不是设备路径（如<code>/dev/block/mmcblk0p5</code>）</td>
</tr>
<tr>
<td><code>CONFIG_APANIC_MMC_MEMDUMP</code></td>
<td>布尔值</td>
<td>启用/关闭崩溃时内存转储。一般用不到</td>
</tr>
</tbody></table>
<p>笔者启用该功能，按如下设置之后重新编译内核。其中<code>splash</code>为eMMC存储器的5号分区（<code>/dev/block/mmcblk0p5</code>）。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_APANIC</span>=y<br><span class="hljs-attr">CONFIG_APANIC_PLABEL</span>=<span class="hljs-string">&quot;splash&quot;</span><br><span class="hljs-attr">CONFIG_APANIC_MMC</span>=y<br><span class="hljs-comment"># CONFIG_APANIC_MMC_MEMDUMP is not set</span><br><span class="hljs-attr">CONFIG_ANDROID_RAM_CONSOLE</span>=y<br></code></pre></td></tr></table></figure>

<h2 id="四、升级代码：更新SELinux"><a href="#四、升级代码：更新SELinux" class="headerlink" title="四、升级代码：更新SELinux"></a>四、升级代码：更新SELinux</h2><p>不积跬步，无以至千里。上一部分解决了内核启动的问题，相当于向前迈进了一大步，内核启动成功也就意味着接下来若遇到问题即可获取并分析内核日志了。然而，真正具有难度的问题，随着实践的深入，正接踵而至。</p>
<h3 id="（一）启用SELinux"><a href="#（一）启用SELinux" class="headerlink" title="（一）启用SELinux"></a>（一）启用SELinux</h3><p>SELinux是Linux重要的安全机制，由NSA（National Security Agency，美国国家安全局）开发并负责维护，其源码位于<code>security/selinux</code>。</p>
<p>使用新的<code>init</code>启动Recovery之后，设备正如预期，产生了panic，随后重启，正常引导进入了ATX。果然如我所愿，我成功抓取到了一个panic日志。其中，<code>init</code>部分的输出，即<code>init</code>程序产生的输出，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;2&gt;[1.0, init] [    4.066347] init: Couldn&#x27;t open /sys/fs/selinux/null: No such file or directory<br>&lt;0&gt;[1.0, init] [    4.066831] Kernel panic - not syncing: Attempted to kill init!<br></code></pre></td></tr></table></figure>

<p>从日志中可知，SELinux若在内核中启用，就会建立一个虚拟文件系统<code>selinuxfs</code>，并在<code>/sys/fs/selinux</code>中建立SELinux的设备节点文件（类似于<code>/dev</code>，但后者是由<code>init</code>生成的，这与<code>init</code>加载前就生成的SELinux设备节点有本质区别）。日志中明确指出的文件<code>/sys/fs/selinux/null</code>起到空设备<code>/dev/null</code>的作用。为什么不用<code>/dev/null</code>？这是因为<code>init</code>启动伊始，并没有建立<code>/dev</code>下的各个节点，<code>init</code>反而负责建立它们。可见，<code>init</code>的启动有赖于SELinux的支持。</p>
<p>事实上，从Android 7.0起，谷歌对Android的设计要求愈发严格，SELinux也就成为了任何Android厂商必须支持的标准，到Android 8.0则开始成为强制性要求。Android的SELinux要求“里应外合”，“外”则为Android的SELinux组件，“内”即为Linux内核中的SELinux机制。实现SELinux的根本是内核中的SELinux机制，Android的SELinux组件主要是调用内核中的API，以此保证系统内外的安全性。正因如此，内核必须支持SELinux。</p>
<p>所幸，早在<code>2.6.35</code>版本中[^follow_my_collections]，Linux就已经引入了SELinux机制。但默认情况下它并未启用，也并未作为Linux默认的安全机制，故用户必须手动启用。在内核配置文件的“<code># Security Options</code>”部分中加入以下配置：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">CONFIG_SECURITY_SELINUX=y							<span class="hljs-comment"># 启用SELinux</span><br>CONFIG_DEFAULT_SECURITY_SELINUX=y					<span class="hljs-comment"># 将SELinux作为默认安全模块</span><br>CONFIG_DEFAULT_SECURITY=<span class="hljs-string">&quot;selinux&quot;</span>					<span class="hljs-comment"># 默认安全模块，与上一个选项同步设置</span><br>CONFIG_SECURITY_SELINUX_BOOTPARAM=y					<span class="hljs-comment"># 是否允许通过内核启动参数控制SELinux</span><br>CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1			<span class="hljs-comment"># 默认SELinux内核启动参数，必须设置为1</span><br>													<span class="hljs-comment"># 0为禁用，1为Enforce，2为Permissive</span><br>CONFIG_SECURITY_SELINUX_DISABLE=n					<span class="hljs-comment"># 是否允许在系统中禁用SELinux</span><br>CONFIG_SECURITY_SELINUX_DEVELOP=y					<span class="hljs-comment"># 是否启用开发者模式</span><br>													<span class="hljs-comment">#  （比如，允许在系统中设置SELinux状态）</span><br>CONFIG_SECURITY_SELINUX_AVC_STATS=y                 <span class="hljs-comment"># 是否记录AVC状态到专门的日志中</span><br><br><span class="hljs-comment"># 以下为已弃用的选项，按下文的“第（五）小节”更新代码后将无效</span><br><span class="hljs-comment">#CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX=y			# 允许自定义PolicyDB版本</span><br><span class="hljs-comment">#CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX_VALUE=30	# 自定义PolicyDB版本</span><br></code></pre></td></tr></table></figure>

<p>SELinux还依赖其他的设置项，因此也要确保下面的项目一并配置正确：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">CONFIG_SECURITY=y<br>CONFIG_SECURITY_NETWORK=y<br>CONFIG_AUDIT=y<br>CONFIG_NET=y<br>CONFIG_INET=y<br></code></pre></td></tr></table></figure>

<p>重新编译内核并应用之，下次panic时即可发现，<code>init</code>不再于此处出错了，而是顺利地开始了后面的进程。</p>
<h3 id="（二）SELinux-PolicyDB版本过旧引发的问题"><a href="#（二）SELinux-PolicyDB版本过旧引发的问题" class="headerlink" title="（二）SELinux PolicyDB版本过旧引发的问题"></a>（二）SELinux PolicyDB版本过旧引发的问题</h3><h4 id="（1）问题描述"><a href="#（1）问题描述" class="headerlink" title="（1）问题描述"></a>（1）问题描述</h4><p>原本想，笔者拥有的<code>3.0.8</code>版本内核已装备了SELinux，加之已将其打开，<code>init</code>的启动应当能够继续。然而殊不知，一个让笔者意想不到的问题发生了。启动未过多久，设备再度panic。获取内核日志，发现<code>init</code>遇到了这样一个错误，使其无法继续：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELinux:  SELinux: policydb version 30 does not match my version range 15-26<br></code></pre></td></tr></table></figure>

<p>这里的PolicyDB，即存放SELinux策略的数据库，为一个二进制文件，由SELinux规则的定义代码（以<code>.te</code>为扩展名）通过<code>checkpolicy</code>工具编译而来。它的版本问题，竟然会影响到SELinux机制的工作，可谓问题重大。</p>
<p>带着疑问，我在Android的SELinux模块（<code>external/selinux</code>）中，以上述错误文本为关键字进行<code>grep</code>搜索。值得注意的是，程序员在编写这些用于日志输出的错误文本时，为了排版美观，作了断行处理；加之日志中的<code>30</code>、<code>15</code>和<code>26</code>一般都是不确定的值：如此使得检索一整段关键字是找不到结果的。故笔者尝试截取其中一部分，如“<code>does not match</code>”。</p>
<p>果然有了结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> grep -rn <span class="hljs-string">&quot;does not match&quot;</span></span><br>libselinux/src/label_file.h:415:		/* Stem of regex does not match requested prefix, discard. */<br>libselinux/src/sestatus.c:108:	 * `curr_seqno&#x27; is always even-number, so it does not match with<br>libsepol/src/ebitmap.c:383:		    (&quot;security: ebitmap: map size %d does not match my size %zu (high bit was %d)\n&quot;,<br>libsepol/src/policydb.c:3913:			ERR(fp-&gt;handle, &quot;policydb version %d does not match &quot;<br></code></pre></td></tr></table></figure>

<p>显然<code>policydb.c</code>的那一项最匹配。打开该源码，定位到相应的位置，发现以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Read the configuration data from a policy database binary</span><br><span class="hljs-comment"> * representation file into a policy database structure.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">policydb_read</span><span class="hljs-params">(<span class="hljs-keyword">policydb_t</span> * p, struct policy_file *fp, <span class="hljs-keyword">unsigned</span> verbose)</span></span><br><span class="hljs-function"></span>&#123;<br>    ......<br>    r_policyvers = buf[bufindex];<br>	<span class="hljs-keyword">if</span> (policy_type == POLICY_KERN) &#123;<br>		<span class="hljs-keyword">if</span> (r_policyvers &lt; POLICYDB_VERSION_MIN ||<br>		    r_policyvers &gt; POLICYDB_VERSION_MAX) &#123;<br>			ERR(fp-&gt;handle, <span class="hljs-string">&quot;policydb version %d does not match &quot;</span><br>			    <span class="hljs-string">&quot;my version range %d-%d&quot;</span>, buf[bufindex],<br>			    POLICYDB_VERSION_MIN, POLICYDB_VERSION_MAX);<br>			<span class="hljs-keyword">return</span> POLICYDB_ERROR;<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (policy_type == POLICY_BASE || policy_type == POLICY_MOD) &#123;<br>		<span class="hljs-keyword">if</span> (r_policyvers &lt; MOD_POLICYDB_VERSION_MIN ||<br>		    r_policyvers &gt; MOD_POLICYDB_VERSION_MAX) &#123;<br>			ERR(fp-&gt;handle, <span class="hljs-string">&quot;policydb module version %d does &quot;</span><br>			    <span class="hljs-string">&quot;not match my version range %d-%d&quot;</span>,<br>			    buf[bufindex], MOD_POLICYDB_VERSION_MIN,<br>			    MOD_POLICYDB_VERSION_MAX);<br>			<span class="hljs-keyword">return</span> POLICYDB_ERROR;<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		assert(<span class="hljs-number">0</span>);<br>	&#125;<br>	bufindex++;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处的条件判断，正是用于在读取PolicyDB时检测PolicyDB的版本，若不符合版本要求，立刻报错返回。其中的两个宏——<code>POLICYDB_VERSION_MAX</code>与<code>POLICYDB_VERSION_MIN</code>，指定了要求的版本范围，它们的定义在头文件<code>libsepol/include/sepol/policydb/policydb.h</code>之中。</p>
<h4 id="（2）Android-SELinux模块中的PolicyDB版本"><a href="#（2）Android-SELinux模块中的PolicyDB版本" class="headerlink" title="（2）Android SELinux模块中的PolicyDB版本"></a>（2）Android SELinux模块中的PolicyDB版本</h4><p>Android SEPolicy模块中头文件<code>libsepol/include/sepol/policydb/policydb.h</code>包含了所有可能的PolicyDB版本。从每个版本的名字可以猜测，它们的“版本”，实际上指的是API的等级，表示它们所支持的功能。最低为<code>POLICYDB_VERSION_BASE</code>（<code>15</code>），最高为<code>POLICYDB_VERSION_XPERMS_IOCTL</code>（<code>30</code>）[^another_highest_poldb_ver]。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Identify specific policy version changes */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_BASE		15</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_BOOL		16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_IPV6		17</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_NLCLASS	18</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_VALIDATETRANS	19</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_MLS		19</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_AVTAB		20</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_RANGETRANS	21</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_POLCAP		22</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_PERMISSIVE	23</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_BOUNDARY	24</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_FILENAME_TRANS	25</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_ROLETRANS	26</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_NEW_OBJECT_DEFAULTS	27</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_DEFAULT_TYPE	28</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_CONSTRAINT_NAMES	29</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_XEN_DEVICETREE		30 <span class="hljs-comment">/* Xen-specific */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_XPERMS_IOCTL	30 <span class="hljs-comment">/* Linux-specific */</span></span><br><br><span class="hljs-comment">/* Range of policy versions we understand*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_MIN	POLICYDB_VERSION_BASE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_MAX	POLICYDB_VERSION_XPERMS_IOCTL</span><br></code></pre></td></tr></table></figure>

<p>最高版本<code>POLICYDB_VERSION_XPERMS_IOCTL</code>是自<code>4.4</code>版内核引入的新PolicyDB版本，<code>XPERMS</code>为extended permissions的缩写，即“扩展权限”。Android 8.0开始的一些安全特性需要用到扩展权限的API，因此对于PolicyDB版本的最低要求升到了30。从Android的SEPolicy配置档案（<code>system/sepolicy</code>）的<code>Android.mk</code>中，我们不难窥知这一点：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># SELinux policy version.</span><br><span class="hljs-comment"># Must be &lt;= /sys/fs/selinux/policyvers reported by the Android kernel.</span><br><span class="hljs-comment"># Must be within the compatibility range reported by checkpolicy -V.</span><br>POLICYVERS ?= 30<br></code></pre></td></tr></table></figure>

<p>然而，SELinux归根到底是由内核实现的功能，Android提供的SELinux模块仅仅是用于调用内核中之SELinux机制的，相当于客户端之于服务器的关系。解铃还须系铃人，要想抓住PolicyDB版本定义的本质，仍须从根本之所在——内核，进行分析。</p>
<h4 id="（3）内核SELinux定义的PolicyDB版本"><a href="#（3）内核SELinux定义的PolicyDB版本" class="headerlink" title="（3）内核SELinux定义的PolicyDB版本"></a>（3）内核SELinux定义的PolicyDB版本</h4><p>内核的PolicyDB版本定义在<code>security/selinux/include/security.h</code>中，如下所示。这里定义的最低版本为<code>POLICYDB_VERSION_BASE</code>（<code>15</code>），最高为<code>POLICYDB_VERSION_ROLETRANS</code>（<code>26</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Identify specific policy version changes */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_BASE		15</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_BOOL		16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_IPV6		17</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_NLCLASS	18</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_VALIDATETRANS	19</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_MLS		19</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_AVTAB		20</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_RANGETRANS	21</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_POLCAP		22</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_PERMISSIVE	23</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_BOUNDARY	24</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_FILENAME_TRANS	25</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_ROLETRANS	26</span><br><br><span class="hljs-comment">/* Range of policy versions we understand*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_MIN   POLICYDB_VERSION_BASE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_MAX	CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX_VALUE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POLICYDB_VERSION_MAX	POLICYDB_VERSION_ROLETRANS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>不难发现，内核SELinux中定义的最高版本，明显要低于Android SELinux模块中所要求的“底线”<code>POLICYDB_VERSION_XPERMS_IOCTL</code>（<code>30</code>），说明现有的<code>3.0.8</code>版本内核并不支持最新的PolicyDB版本。在此情形下，出错是必然的。</p>
<p><strong>解决问题的方向只有一个：升级SELinux源码。</strong></p>
<h3 id="（三）就地升级"><a href="#（三）就地升级" class="headerlink" title="（三）就地升级"></a>（三）就地升级</h3><p>代码的升级，以新版本内核<code>4.17</code>为蓝本。操作的思想是，找出新版内核SELinux源码中与最新的PolicyDB版本<code>POLICYDB_VERSION_XPERMS_IOCTL</code>有关的代码，然后在<code>3.0.8</code>的旧版本内核中实现它们。而寻找不同之处，最便捷直接的手段，莫过于用比较工具。笔者选用的是<strong>Meld</strong>。</p>
<h4 id="（1）抓住重点文件"><a href="#（1）抓住重点文件" class="headerlink" title="（1）抓住重点文件"></a>（1）抓住重点文件</h4><p>打开Meld，选择“目录比较（Directory comparison）”，两边分别指定为旧版本与新版本内核的<code>security/selinux</code>目录。然后在工具栏上把“显示相同文件（Show identical，按钮文本为“Same”）”按钮取消，只按下“显示新文件（Show new）”和“显示已修改文件（Show modified）”，以确保只显示两边不同的文件。</p>
<p>面对纷繁复杂的文件列表，须确定一个比较的重点。此刻的重点，即为围绕两个关键点查找相关的源文件——PolicyDB与<code>XPERMS</code>。笔者的做法是，以<code>XPERMS</code>为关键词（忽略大小写），使用<code>grep -l</code>检索出包含该关键词的文件列表[^grep_arguments_2]，据此发现了以下直接与<code>XPERMS</code>相关的源文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> grep -ril <span class="hljs-string">&quot;XPERMS&quot;</span></span><br>avc.c<br>include/avc.h<br>include/security.h<br>ss/avtab.c<br>ss/avtab.h<br>ss/conditional.c<br>ss/conditional.h<br>ss/policydb.c<br>ss/services.c<br>ss/services.h<br></code></pre></td></tr></table></figure>

<p>这种以关键字为准的判断方法，得出来的结果比较粗略，它并未考虑到代码上下文的关系。一些包含<code>xperms</code>关键字的函数有可能还调用了上述文件以外、且同样需要修改的函数。因此还须在实践中找出“漏网之鱼”。</p>
<h4 id="（2）明晰二者差异"><a href="#（2）明晰二者差异" class="headerlink" title="（2）明晰二者差异"></a>（2）明晰二者差异</h4><p>源码升级不是一个简单的问题，版本跨越幅度之大，使得升级过程中要注意的细节为数不少。在使用Meld比较的过程中，软件显示出的差异常常占据导航栏相当大的比重。笔者在观察源码时，发现了<code>4.17</code>版本和<code>3.0.8</code>版本SELinux源码的以下不同之处：</p>
<h5 id="1-新增功能"><a href="#1-新增功能" class="headerlink" title="1. 新增功能"></a>1. 新增功能</h5><p>XPERMS属于新功能，因而<code>4.17</code>版本相比<code>3.0.8</code>，最明显的变化在于<strong>多出了很多与XPERMS相关的函数。</strong>它们表现如下：</p>
<ul>
<li><code>avc.c</code><ul>
<li>加入了以<code>avc_xperms_</code>为前缀的结构体与函数。</li>
<li>主要的一部分函数加入了与XPERMS相关的参数。</li>
</ul>
</li>
<li><code>security.h</code><ul>
<li>加入了最新的PolicyDB API定义，即<code>POLICYDB_VERSION_XPERMS_IOCTL</code>与<code>POLICYDB_VERSION_INFINIBAND</code>，分别为<code>30</code>和<code>31</code>。</li>
<li>加入了XPERMS相关的基本结构体，如<code>extended_perms</code>。</li>
</ul>
</li>
<li><code>avtab.c</code><ul>
<li>加入了处理XPERMS的代码。</li>
</ul>
</li>
<li><code>policydb.c</code><ul>
<li>在结构体数组<code>policydb_compat</code>中加入了XPERMS的条目。</li>
</ul>
</li>
</ul>
<h5 id="2-重写原有代码"><a href="#2-重写原有代码" class="headerlink" title="2. 重写原有代码"></a>2. 重写原有代码</h5><p>新版本与旧版本的代码，大部分均实现相同的功能，但新版本对旧版本中的很多函数均进行了重构，使得代码的实现千差万别。表现列举如下：</p>
<ul>
<li><strong>将旧版本函数中的一段代码块整合成单独的函数。</strong></li>
</ul>
<p>函数中的一段代码块能够实现一个既定的小目标。这时，为了代码简洁的考虑，开发者会将这些代码块单独提取出来，写成一个单独的函数，再在原函数中调用它以实现与原先相同的功能。比对两版本代码中同一个函数的程序逻辑时，若发现这样的情况，则须找出新版本中“独立成家”的代码块，才能避免“漏网之鱼”，导致最终得到的代码出现意想不到的Bug。</p>
<p>典型的例子有<code>avc.c</code>中的<code>avc_has_perm_noaudit()</code>函数。<code>3.0.8</code>的其中一段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avc_has_perm_noaudit</span><span class="hljs-params">(u32 ssid, u32 tsid,</span></span><br><span class="hljs-params"><span class="hljs-function">			 u16 tclass, u32 requested,</span></span><br><span class="hljs-params"><span class="hljs-function">			 <span class="hljs-keyword">unsigned</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">			 struct av_decision *avd)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">avc_node</span> *<span class="hljs-title">node</span>;</span><br>	......<br><br>	rcu_read_lock();<br><br>	node = avc_lookup(ssid, tsid, tclass);<br>	<span class="hljs-keyword">if</span> (unlikely(!node)) &#123;<br>		rcu_read_unlock();<br>		security_compute_av(ssid, tsid, tclass, avd);<br>		rcu_read_lock();<br>		node = avc_insert(ssid, tsid, tclass, avd);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-built_in">memcpy</span>(avd, &amp;node-&gt;ae.avd, <span class="hljs-keyword">sizeof</span>(*avd));<br>		avd = &amp;node-&gt;ae.avd;<br>	&#125;<br><br>    ......<br>&#125;     <br></code></pre></td></tr></table></figure>

<p>但是在<code>4.17</code>中，则变成了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">avc_has_perm_noaudit</span><span class="hljs-params">(struct selinux_state *state,</span></span><br><span class="hljs-params"><span class="hljs-function">				u32 ssid, u32 tsid,</span></span><br><span class="hljs-params"><span class="hljs-function">				u16 tclass, u32 requested,</span></span><br><span class="hljs-params"><span class="hljs-function">				<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">				struct av_decision *avd)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">avc_node</span> *<span class="hljs-title">node</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">avc_xperms_node</span> <span class="hljs-title">xp_node</span>;</span><br>	......<br><br>	rcu_read_lock();<br><br>	node = avc_lookup(state-&gt;avc, ssid, tsid, tclass);<br>	<span class="hljs-keyword">if</span> (unlikely(!node))<br>		node = avc_compute_av(state, ssid, tsid, tclass, avd, &amp;xp_node);<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-built_in">memcpy</span>(avd, &amp;node-&gt;ae.avd, <span class="hljs-keyword">sizeof</span>(*avd));<br><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>重点在<code>if (unlikely(!node))</code>之中。</strong>在<code>3.0.8</code>中，<code>if</code>分支里还是由四行代码组成的代码块；但在<code>4.17</code>中却变成了一行有函数调用的赋值语句，调用的是函数<code>avc_compute_av()</code>。这一差别实在是不小。</p>
<p>索性浏览一下<code>avc_compute_av()</code>的定义，会发现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> noinline</span><br><span class="hljs-function">struct avc_node *<span class="hljs-title">avc_compute_av</span><span class="hljs-params">(struct selinux_state *state,</span></span><br><span class="hljs-params"><span class="hljs-function">				u32 ssid, u32 tsid,</span></span><br><span class="hljs-params"><span class="hljs-function">				u16 tclass, struct av_decision *avd,</span></span><br><span class="hljs-params"><span class="hljs-function">				struct avc_xperms_node *xp_node)</span></span><br><span class="hljs-function"></span>&#123;<br>	rcu_read_unlock();<br>	INIT_LIST_HEAD(&amp;xp_node-&gt;xpd_head);<br>	security_compute_av(state, ssid, tsid, tclass, avd, &amp;xp_node-&gt;xp);<br>	rcu_read_lock();<br>	<span class="hljs-keyword">return</span> avc_insert(state-&gt;avc, ssid, tsid, tclass, avd, xp_node);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这实际上就是<code>3.0.8</code>中相应的代码块！除了<code>INIT_LIST_HEAD</code>是与新功能有关的代码之外，其余的代码本质均相同，最终均归为给指针变量<code>*node</code>赋值。</p>
<ul>
<li><strong>加入了新的数据结构。</strong></li>
<li><strong>函数接口发生了变化。</strong></li>
</ul>
<blockquote>
<p>e.g. </p>
<ul>
<li>引入struct selinux_state所致的一系列变化！</li>
<li>list.h接口的变化，如hlist_for_each_entry</li>
</ul>
</blockquote>
<h4 id="（3）巧妙移植"><a href="#（3）巧妙移植" class="headerlink" title="（3）巧妙移植"></a>（3）巧妙移植</h4><h4 id="（4）总结"><a href="#（4）总结" class="headerlink" title="（4）总结"></a>（4）总结</h4><hr>
<p>列举出旧版内核中最终修改的文件。以下为<code>diffstat</code>工具对整理出来的修改前后差异：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">include/linux/fs.h                  |    <span class="hljs-number">2</span> <br>security/selinux/avc.c              |  <span class="hljs-number">354</span> +++++++++++++++++++++++++++++++++++-<br>security/selinux/include/avc.h      |    <span class="hljs-number">8</span> <br>security/selinux/include/security.h |   <span class="hljs-number">40</span> +++-<br>security/selinux/ss/avtab.c         |   <span class="hljs-number">99</span> ++++++++--<br>security/selinux/ss/avtab.h         |   <span class="hljs-number">36</span> +++<br>security/selinux/ss/conditional.c   |   <span class="hljs-number">29</span> ++<br>security/selinux/ss/conditional.h   |    <span class="hljs-number">5</span> <br>security/selinux/ss/constraint.h    |    <span class="hljs-number">1</span> <br>security/selinux/ss/policydb.c      |  <span class="hljs-number">235</span> ++++++++++++++++++++++-<br>security/selinux/ss/policydb.h      |   <span class="hljs-number">38</span> +++<br>security/selinux/ss/services.c      |  <span class="hljs-number">216</span> ++++++++++++++++++++-<br>security/selinux/ss/services.h      |   <span class="hljs-number">24</span> ++<br><span class="hljs-number">13</span> files changed, <span class="hljs-number">1031</span> insertions(+), <span class="hljs-number">56</span> deletions(-)<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="五、持续跟进：修复启动错误"><a href="#五、持续跟进：修复启动错误" class="headerlink" title="五、持续跟进：修复启动错误"></a>五、持续跟进：修复启动错误</h2><p>升级了SELinux之后，原本近乎停滞的开发进程得以继续，下一步就是要把前方遇到的新问题一一进行解决。</p>
<h3 id="（一）修正init在检测到panic时的处理机制"><a href="#（一）修正init在检测到panic时的处理机制" class="headerlink" title="（一）修正init在检测到panic时的处理机制"></a>（一）修正<code>init</code>在检测到panic时的处理机制</h3><p>内核启动一段时间后，即把控制权交予位于ramdisk根目录的初始化程序<code>init</code>，所以不难判断之后的重启均由该程序引发。类比其他Linux发行版的策略，理论上<code>init</code>所发生的任何异常都会导致panic重启，可以让用户通过技术手段获取panic日志。这些异常，有的是<code>init</code>内部错误处理程序触发，也有的是<code>init</code>本身发生了崩溃（如段错误（segmentation fault））。</p>
<p>但笔者在调试过程中发现，并不是所有的重启，都能在ATX中使用<code>cat /dev/block/mmcblk0p5</code>命令读取<code>splash</code>分区获得日志。有时重启会输出panic日志；而有时检查日志中的崩溃时间标记，发现该分区的内容保持原样（<code>APANIC_MMC</code>并不支持擦除分区并覆盖原有日志）。笔者试图分析偶尔留下的panic日志，发现内核关于panic的报错提示均为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;0&gt;[1.0, init] [    4.066831] Kernel panic - not syncing: Attempted to kill init!<br></code></pre></td></tr></table></figure>

<p>仅仅得知这一条日志是不够的，加之只有一部分重启有日志，资料不完备，因此笔者只能从<code>init</code>的源代码入手分析。</p>
<h4 id="（1）找出与panic相关的源文件"><a href="#（1）找出与panic相关的源文件" class="headerlink" title="（1）找出与panic相关的源文件"></a>（1）找出与panic相关的源文件</h4><p><code>init</code>的源码位于Android源码的<code>system/core/init</code>下。为了找出与panic有关的代码，笔者首先在其中用<code>grep</code>检索关键字<code>panic</code>[^grep_arguments]，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> grep -rin <span class="hljs-string">&quot;panic&quot;</span></span><br>Android.bp:31:        &quot;-DREBOOT_BOOTLOADER_ON_PANIC=0&quot;,<br>Android.bp:43:                &quot;-UREBOOT_BOOTLOADER_ON_PANIC&quot;,<br>Android.bp:44:                &quot;-DREBOOT_BOOTLOADER_ON_PANIC=1&quot;,<br>Android.mk:11:    -DREBOOT_BOOTLOADER_ON_PANIC=1 \<br>Android.mk:17:    -DREBOOT_BOOTLOADER_ON_PANIC=0 \<br>init.cpp:237:    // property. We still panic if it takes more than a minute though,<br>init.cpp:242:        panic();<br>init.cpp:327:    panic();<br>init.cpp:887:            panic();<br>init.cpp:964:    // Instead of panic&#x27;ing the kernel as is the default behavior when init crashes,<br>init.cpp:978:        // panic() reboots to bootloader<br>init.cpp:979:        panic();<br>init.cpp:1003:    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;<br>init.cpp:1043:            panic();<br>init.cpp:1069:        // panic and never fall through this conditional.<br>service.cpp:331:                panic();<br>util.cpp:373:void panic() &#123;<br>util.cpp:374:    LOG(ERROR) &lt;&lt; &quot;panic: rebooting to bootloader&quot;;<br>util.h:56:void panic() __attribute__((__noreturn__));<br></code></pre></td></tr></table></figure>

<p>一般地，包含有文本“<code>panic</code>”（或“<code>PANIC</code>”）的源文件均与<code>init</code>对panic的处理有关。下一步，即为逐一分析以上涉及到的文件，根据行号定位到相应的代码处。</p>
<h4 id="（2）分析代码"><a href="#（2）分析代码" class="headerlink" title="（2）分析代码"></a>（2）分析代码</h4><h5 id="1-init-cpp"><a href="#1-init-cpp" class="headerlink" title="1. init.cpp"></a>1. <code>init.cpp</code></h5><p><code>init.cpp</code>是<code>init</code>的主程序，<code>main()</code>函数位于其中。一个函数<code>InstallRebootSignalHandlers()</code>用于指定处理信号的动作，使<code>init</code>在收到异常信号（如<code>SIGINT</code>、<code>SIGABRT</code>）后，调用<code>panic()</code>函数。<code>panic()</code>会直接让系统重启进入Bootloader。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InstallRebootSignalHandlers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Instead of panic&#x27;ing the kernel as is the default behavior when init crashes,</span><br>    <span class="hljs-comment">// we prefer to reboot to bootloader on development builds, as this will prevent</span><br>    <span class="hljs-comment">// boot looping bad configurations and allow both developers and test farms to easily</span><br>    <span class="hljs-comment">// recover.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">action</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;action, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(action));<br>    <span class="hljs-built_in">sigfillset</span>(&amp;action.sa_mask);<br>    action.sa_handler = [](<span class="hljs-keyword">int</span> signal) &#123;<br>        <span class="hljs-comment">// These signal handlers are also caught for processes forked from init, however we do not</span><br>        <span class="hljs-comment">// want them to trigger reboot, so we directly call _exit() for children processes here.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getpid</span>() != <span class="hljs-number">1</span>) &#123;<br>            _exit(signal);<br>        &#125;<br><br>        <span class="hljs-comment">// panic() reboots to bootloader</span><br>        <span class="hljs-built_in">panic</span>();<br>    &#125;;<br>    action.sa_flags = SA_RESTART;<br>    <span class="hljs-built_in">sigaction</span>(SIGABRT, &amp;action, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">sigaction</span>(SIGBUS, &amp;action, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">sigaction</span>(SIGFPE, &amp;action, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">sigaction</span>(SIGILL, &amp;action, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">sigaction</span>(SIGSEGV, &amp;action, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(SIGSTKFLT)</span><br>    <span class="hljs-built_in">sigaction</span>(SIGSTKFLT, &amp;action, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-built_in">sigaction</span>(SIGSYS, &amp;action, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">sigaction</span>(SIGTRAP, &amp;action, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这项工作在<code>main</code>函数开始不久后进行。阅读代码发现，宏<code>REBOOT_BOOTLOADER_ON_PANIC</code>控制是否进行这项工作，若设为<code>false</code>(<code>0</code>)，则上述信号产生时内核直接崩溃重启，而不再进入Bootloader。信号产生的大多数情况是<code>init</code>程序意外崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(<span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;ueventd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ueventd_main</span>(argc, argv);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(<span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;watchdogd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">watchdogd_main</span>(argc, argv);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;<br>        <span class="hljs-built_in">InstallRebootSignalHandlers</span>();<br>    &#125;<br>    <br>    ......<br></code></pre></td></tr></table></figure>

<p>除此之外，阅读<code>grep</code>的输出结果还可发现，在一些函数中也分布着对<code>panic()</code>的调用。有别于<code>InstallRebootSignalHandlers</code>中因异常而产生的信号触发，它们均为开发者手动调用，通常是在出现不可逆转的严重错误（unrecoverable fatal error）时立刻重启，进入Bootloader。比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selinux_initialize</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> in_kernel_domain)</span> </span>&#123;<br>	......<br><br>    <span class="hljs-keyword">if</span> (in_kernel_domain) &#123;<br>        <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Loading SELinux policy&quot;</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">selinux_load_policy</span>()) &#123;<br>            <span class="hljs-built_in">panic</span>();<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>此处调用<code>selinux_load_policy</code>来加载SELinux策略（SELinux policy）。8.0开始Android将SELinux视为强制性要求，必须加载SELinux策略才允许启动。因此SELinux加载失败，即为不可逆转的严重错误，必须重启。</p>
<p>根据<code>InstallRebootSignalHandlers()</code>的注释可知，<code>init</code>开发者的用意，就是对于开发环境，将panic时自动重启进入Bootloader视为默认动作，以免设备在panic时使用错误的内核配置无限重启，由此利于客户开发者和测试者（均为谷歌公司的客户）在Bootloader中恢复设备。</p>
<p>笔者认为这一设计有利有弊。它易于恢复设备这一优点，适用于有足够条件进行完备测试的工厂环境。因工厂环境支持串口调试等若干更为高级、更为底层的方式调试内核，调试方式独立于Android系统，可以在脱离Android的情况下轻易获取内核日志，不需要以用启动镜像启动系统的形式来获取。然而，笔者的情况相对<code>init</code>开发者的的设想，尤为特殊：缺乏串口调试等途径，使得panic重启成为了唯一能够获取内核日志的方式——原本的处理逻辑不再适用。为此，笔者将在下一节中对相关代码进行修改。</p>
<p>观察以上代码，不难看出，<code>init.cpp</code>更多地是在调用在其他源文件中所定义的函数与宏，故实际操作中并不需要修改这个文件，应当追根溯源。</p>
<h5 id="2-Android-bp与Android-mk"><a href="#2-Android-bp与Android-mk" class="headerlink" title="2. Android.bp与Android.mk"></a>2. <code>Android.bp</code>与<code>Android.mk</code></h5><p>二者都是编译系统的入口文件，作用相同，只是调用它们的是不同的程序。<code>Android.bp</code>由Android的新版编译系统Soong使用，为支持注释的JSON格式；而<code>Android.mk</code>则是Makefile，由GNU Make使用。事实上，Soong会通过一个转换程序CKati，将<code>Android.mk</code>转换成另一款编译系统Ninja的配置文件，不过现阶段二者仍然共存，均发挥彼此不可替代的作用。</p>
<p>两种配置文件都定义了编译C++源文件时，需要传递给编译器的一些参数，其中就包括了对宏<code>REBOOT_BOOTLOADER_ON_PANIC</code>的定义。编译器接收<code>-D&lt;MacroName&gt;</code>或<code>-D&lt;MacroName&gt;=&lt;Value&gt;</code>参数，用于在编译时定义宏，等价于在源码开头添加<code>#define &lt;MacroName&gt; &lt;Value&gt;</code>；对应的取消定义宏之参数为<code>-U&lt;MacroName&gt;</code>，等价于<code>#undef &lt;MacroName&gt;</code>。</p>
<p><code>Android.bp</code>的有关部分如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs JSON">cc_defaults &#123;<br>    name: <span class="hljs-string">&quot;init_defaults&quot;</span>,<br>    cpp_std: <span class="hljs-string">&quot;experimental&quot;</span>,<br>    sanitize: &#123;<br>        misc_undefined: [<span class="hljs-string">&quot;signed-integer-overflow&quot;</span>],<br>    &#125;,<br>    cppflags: [<br>        <span class="hljs-string">&quot;-DLOG_UEVENTS=0&quot;</span>,<br>        <span class="hljs-string">&quot;-Wall&quot;</span>,<br>        <span class="hljs-string">&quot;-Wextra&quot;</span>,<br>        <span class="hljs-string">&quot;-Wno-unused-parameter&quot;</span>,<br>        <span class="hljs-string">&quot;-Werror&quot;</span>,<br>        <span class="hljs-string">&quot;-DALLOW_LOCAL_PROP_OVERRIDE=1&quot;</span>,<br>        <span class="hljs-string">&quot;-DALLOW_PERMISSIVE_SELINUX=0&quot;</span>,<br>        <span class="hljs-string">&quot;-DREBOOT_BOOTLOADER_ON_PANIC=0&quot;</span>,<br>        <span class="hljs-string">&quot;-DWORLD_WRITABLE_KMSG=0&quot;</span>,<br>        <span class="hljs-string">&quot;-DDUMP_ON_UMOUNT_FAILURE=0&quot;</span>,<br>        <span class="hljs-string">&quot;-DSHUTDOWN_ZERO_TIMEOUT=0&quot;</span>,<br>    ],<br>    product_variables: &#123;<br>        debuggable: &#123;<br>            cppflags: [<br>                <span class="hljs-string">&quot;-UALLOW_LOCAL_PROP_OVERRIDE&quot;</span>,<br>                <span class="hljs-string">&quot;-DALLOW_LOCAL_PROP_OVERRIDE=1&quot;</span>,<br>                <span class="hljs-string">&quot;-UALLOW_PERMISSIVE_SELINUX&quot;</span>,<br>                <span class="hljs-string">&quot;-DALLOW_PERMISSIVE_SELINUX=1&quot;</span>,<br>                <span class="hljs-string">&quot;-UREBOOT_BOOTLOADER_ON_PANIC&quot;</span>,<br>                <span class="hljs-string">&quot;-DREBOOT_BOOTLOADER_ON_PANIC=1&quot;</span>,<br>                <span class="hljs-string">&quot;-UWORLD_WRITABLE_KMSG&quot;</span>,<br>                <span class="hljs-string">&quot;-DWORLD_WRITABLE_KMSG=1&quot;</span>,<br>                <span class="hljs-string">&quot;-UDUMP_ON_UMOUNT_FAILURE&quot;</span>,<br>                <span class="hljs-string">&quot;-DDUMP_ON_UMOUNT_FAILURE=1&quot;</span>,<br>            ],<br>        &#125;,<br>        eng: &#123;<br>            cppflags: [<br>                <span class="hljs-string">&quot;-USHUTDOWN_ZERO_TIMEOUT&quot;</span>,<br>                <span class="hljs-string">&quot;-DSHUTDOWN_ZERO_TIMEOUT=1&quot;</span>,<br>            ],<br>        &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码中的对象<code>cc_defaults</code>是对编译器的配置。其中<code>cc_defaults.cppflags</code>数组指定传递给编译器的参数；而<code>cc_defaults.product_variables</code>则指定不同的产品变量（product variable）应当使用的专用设置。专用设置中的<code>cppflags</code>会在运行编译器时追加于上方的<code>cc_defaults.cppflags</code>之后。</p>
<p>上述代码中，<code>REBOOT_BOOTLOADER_ON_PANIC</code>宏在<code>cc_defaults.cppflags</code>中定义为<code>0</code>，表示默认禁止在panic时重启到Bootloader中；但是下方产品变量<code>debuggable</code>所对应的<code>cppflags</code>中，则将原先的宏定义取消了，取而代之地将其定义为<code>1</code>，表示启用。Soong编译系统将<code>userdebug</code>和<code>eng</code>视为<code>debuggable</code>。</p>
<p>对应地， <code>Android.mk</code>的有关部分如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifneq</span> (,<span class="hljs-variable">$(<span class="hljs-built_in">filter</span> userdebug eng,<span class="hljs-variable">$(TARGET_BUILD_VARIANT)</span>)</span>)<br>init_options += \<br>    -DALLOW_LOCAL_PROP_OVERRIDE=1 \<br>    -DALLOW_PERMISSIVE_SELINUX=1 \<br>    -DREBOOT_BOOTLOADER_ON_PANIC=1 \<br>    -DDUMP_ON_UMOUNT_FAILURE=1<br><span class="hljs-keyword">else</span><br>init_options += \<br>    -DALLOW_LOCAL_PROP_OVERRIDE=0 \<br>    -DALLOW_PERMISSIVE_SELINUX=0 \<br>    -DREBOOT_BOOTLOADER_ON_PANIC=0 \<br>    -DDUMP_ON_UMOUNT_FAILURE=0<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>

<p>在Makefile的语法中：<code>filter &lt;关键词组&gt;,&lt;字符串&gt;</code>判断字符串的值是否符合关键词组的其中之一，用于过滤出符合关键词组的子串，若不满足条件则返回空值。条件判断<code>ifneq (&lt;判定值&gt;, &lt;表达式&gt;)</code>判断表达式的值是否不等于第一个参数给定的判定值。</p>
<p>由此，不难理解整段代码的含义。根据构建变量的不同，会相应地给编译器传递不同的参数，由变量<code>init_options</code>传递。该段代码会判断用户指定的编译变量<code>TARGET_BUILD_VARIANT</code>是否为<code>userdebug</code>与<code>eng</code>，若是，则将<code>REBOOT_BOOTLOADER_ON_PANIC</code>宏设为<code>1</code>，否则设为<code>0</code>。</p>
<p>修改时，只需要将编译参数中<code>REBOOT_BOOTLOADER_ON_PANIC</code>的值一律设为<code>0</code>即可。为了确保一致性，两个文件均需同时修改。</p>
<h5 id="3-util-cpp"><a href="#3-util-cpp" class="headerlink" title="3. util.cpp"></a>3. <code>util.cpp</code></h5><p><code>util.cpp</code>相当于一个工具箱，提供了一些实用的函数，在其他源文件中调用。百川东到海，<code>init.cpp</code>中触发重启进Bootloader的<code>panic()</code>函数就是在这里定义的。</p>
<p><code>panic()</code>函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">panic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;panic: rebooting to bootloader&quot;</span>;<br>    <span class="hljs-comment">// Do not queue &quot;shutdown&quot; trigger since we want to shutdown immediately</span><br>    <span class="hljs-built_in">DoReboot</span>(ANDROID_RB_RESTART2, <span class="hljs-string">&quot;reboot&quot;</span>, <span class="hljs-string">&quot;bootloader&quot;</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然，该函数的作用很简单：调用<code>DoReboot()</code>，以重启进入Bootloader。<code>DoReboot()</code>是Android NDK的一个函数，用于重启设备，支持重启进入特定的模式。</p>
<p>由此可知，修改<code>panic()</code>函数，正是修改<code>init</code>源码这项任务的重中之重。</p>
<h4 id="（3）修改代码"><a href="#（3）修改代码" class="headerlink" title="（3）修改代码"></a>（3）修改代码</h4><p>掌握原理后，即可立刻着手修改代码。对代码的修改以<code>diff</code>的形式展示如下。</p>
<h5 id="1-Android-bp与Android-mk"><a href="#1-Android-bp与Android-mk" class="headerlink" title="1. Android.bp与Android.mk"></a>1. <code>Android.bp</code>与<code>Android.mk</code></h5><p>把所有定义<code>REBOOT_BOOTLOADER_ON_PANIC</code>宏的值均改为<code>0</code>。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/init/Android.bp b/init/Android.bp</span><br><span class="hljs-comment">index 45cf327f8..8a16fb2d2 100644</span><br><span class="hljs-comment">--- a/init/Android.bp</span><br><span class="hljs-comment">+++ b/init/Android.bp</span><br><span class="hljs-meta">@@ -14,6 +14,9 @@</span><br> // limitations under the License.<br> //<br><br><span class="hljs-addition">+// AnClark modify: I want to read logs. If handles panic as rebooting into bootloader, I won&#x27;t get any logs!</span><br><span class="hljs-addition">+// Force setting DREBOOT_BOOTLOADER_ON_PANIC=0 on product_variables.</span><br><span class="hljs-addition">+</span><br> cc_defaults &#123;<br>     name: &quot;init_defaults&quot;,<br>     cpp_std: &quot;experimental&quot;,<br><span class="hljs-meta">@@ -41,7 +44,7 @@</span> cc_defaults &#123;<br>                 &quot;-UALLOW_PERMISSIVE_SELINUX&quot;,<br>                 &quot;-DALLOW_PERMISSIVE_SELINUX=1&quot;,<br>                 &quot;-UREBOOT_BOOTLOADER_ON_PANIC&quot;,<br><span class="hljs-deletion">-                &quot;-DREBOOT_BOOTLOADER_ON_PANIC=1&quot;,</span><br><span class="hljs-addition">+                &quot;-DREBOOT_BOOTLOADER_ON_PANIC=0&quot;,</span><br>                 &quot;-UWORLD_WRITABLE_KMSG&quot;,<br>                 &quot;-DWORLD_WRITABLE_KMSG=1&quot;,<br>                 &quot;-UDUMP_ON_UMOUNT_FAILURE&quot;,<br><span class="hljs-comment">diff --git a/init/Android.mk b/init/Android.mk</span><br><span class="hljs-comment">index f1fe5168b..d28b4e489 100644</span><br><span class="hljs-comment">--- a/init/Android.mk</span><br><span class="hljs-comment">+++ b/init/Android.mk</span><br><span class="hljs-meta">@@ -5,10 +5,12 @@</span> LOCAL_PATH:= $(call my-dir)<br> # --<br><br> ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))<br><span class="hljs-addition">+# AnClark modify: I want to read logs. If handles panic as rebooting into bootloader, I won&#x27;t get any logs!</span><br><span class="hljs-addition">+# Force setting DREBOOT_BOOTLOADER_ON_PANIC=0 on product_variables.</span><br> init_options += \<br>     -DALLOW_LOCAL_PROP_OVERRIDE=1 \<br>     -DALLOW_PERMISSIVE_SELINUX=1 \<br><span class="hljs-deletion">-    -DREBOOT_BOOTLOADER_ON_PANIC=1 \</span><br><span class="hljs-addition">+    -DREBOOT_BOOTLOADER_ON_PANIC=0 \</span><br>     -DDUMP_ON_UMOUNT_FAILURE=1<br> else<br> init_options += \<br></code></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/init/Android.mk b/init/Android.mk</span><br><span class="hljs-comment">index f1fe5168b..d28b4e489 100644</span><br><span class="hljs-comment">--- a/init/Android.mk</span><br><span class="hljs-comment">+++ b/init/Android.mk</span><br><span class="hljs-meta">@@ -5,10 +5,12 @@</span> LOCAL_PATH:= $(call my-dir)<br> # --<br><br> ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))<br><span class="hljs-addition">+# AnClark modify: I want to read logs. If handles panic as rebooting into bootloader, I won&#x27;t get any logs!</span><br><span class="hljs-addition">+# Force setting DREBOOT_BOOTLOADER_ON_PANIC=0 on product_variables.</span><br> init_options += \<br>     -DALLOW_LOCAL_PROP_OVERRIDE=1 \<br>     -DALLOW_PERMISSIVE_SELINUX=1 \<br><span class="hljs-deletion">-    -DREBOOT_BOOTLOADER_ON_PANIC=1 \</span><br><span class="hljs-addition">+    -DREBOOT_BOOTLOADER_ON_PANIC=0 \</span><br>     -DDUMP_ON_UMOUNT_FAILURE=1<br> else<br> init_options += \<br></code></pre></td></tr></table></figure>

<h5 id="2-util-cpp"><a href="#2-util-cpp" class="headerlink" title="2. util.cpp"></a>2. <code>util.cpp</code></h5><p>将<code>panic()</code>函数中调用<code>DoReboot()</code>的部分改为<code>abort()</code>。<code>abort()</code>的作用是强行终止程序，由于调用它的是初始化程序<code>init</code>，故内核会将其视为异常，从而触发panic。利用此原理，即可在任何条件下<code>init</code>发生错误时，都能因panic而抓取到内核日志。另外，为区分<code>init</code>终止的原因是程序崩溃还是手动触发，笔者还在<code>abort()</code>函数之前加入了有辨识度的日志输出[^printk]：若为手动触发，则输出一行日志——“<code>android::init::panic() invoked. Abort init to trigger kernel panic!</code>”。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/init/util.cpp b/init/util.cpp</span><br><span class="hljs-comment">index fdcb22d1c..a468082af 100644</span><br><span class="hljs-comment">--- a/init/util.cpp</span><br><span class="hljs-comment">+++ b/init/util.cpp</span><br><span class="hljs-meta">@@ -370,11 +370,19 @@</span> bool expand_props(const std::string&amp; src, std::string* dst) &#123;<br>     return true;<br> &#125;<br><br><span class="hljs-addition">+// AnClark MODIFY: Use abort() instead of rebooting into BL to trigger panic.</span><br><span class="hljs-addition">+/**</span><br> void panic() &#123;<br>     LOG(ERROR) &lt;&lt; &quot;panic: rebooting to bootloader&quot;;<br>     // Do not queue &quot;shutdown&quot; trigger since we want to shutdown immediately<br>     DoReboot(ANDROID_RB_RESTART2, &quot;reboot&quot;, &quot;bootloader&quot;, false);<br> &#125;<br><span class="hljs-addition">+**/</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+void panic() &#123;</span><br><span class="hljs-addition">+   LOG(ERROR) &lt;&lt; &quot;android::init::panic() invoked. Abort init to trigger kernel panic!&quot;;</span><br><span class="hljs-addition">+   abort();</span><br><span class="hljs-addition">+&#125;</span><br><br> static std::string init_android_dt_dir() &#123;<br>     // Use the standard procfs-based path by default<br></code></pre></td></tr></table></figure>

<h4 id="（4）重新编译"><a href="#（4）重新编译" class="headerlink" title="（4）重新编译"></a>（4）重新编译</h4><p>完成上述修改后，须重新编译Android方可生效。无论是<code>make</code>还是<code>make recoveryimage</code>，均会强制重新编译<code>init</code>。</p>
<p>也可以在<code>system/core/init</code>目录下运行以下命令，单独编译<code>init</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mm<br></code></pre></td></tr></table></figure>

<p>新的<code>init</code>可执行文件为：</p>
<p><code>out/target/product/hwp6_u06/obj/EXECUTABLES/init_intermediates/init</code>。</p>
<h3 id="（二）为内核打补丁"><a href="#（二）为内核打补丁" class="headerlink" title="（二）为内核打补丁"></a>（二）为内核打补丁</h3><h4 id="（1）解决“Could-not-set-context-for-init”问题"><a href="#（1）解决“Could-not-set-context-for-init”问题" class="headerlink" title="（1）解决“Could not set context for /init”问题"></a>（1）解决“<code>Could not set context for /init</code>”问题</h4><p>接下来的研究，进入了“发现一起，查处一起”的查错模式，依赖于日志的变化以找出症结所在。</p>
<p>下一个panic日志与以往有所不同了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;6&gt;[1.0, init] [    4.095564] init: init first stage started!<br>&lt;6&gt;[1.0, init] [    4.095759] init: First stage mount skipped (recovery mode)<br>&lt;6&gt;[1.0, init] [    4.096772] init: Using Android DT directory /proc/device-tree/firmware/android/<br>&lt;6&gt;[1.0, init] [    4.097008] init: Skipped setting INIT_AVB_VERSION (not vbmeta compatible)<br>&lt;6&gt;[1.0, init] [    4.097122] init: Loading SELinux policy<br>&lt;7&gt;[1.0, init] [    4.111902] SELinux: 4096 avtab hash slots, 11631 rules.<br>&lt;7&gt;[1.0, init] [    4.129907] SELinux: 4096 avtab hash slots, 11631 rules.<br>&lt;7&gt;[1.0, init] [    4.129972] SELinux:  1 users, 2 roles, 1115 types, 0 bools, 1 sens, 1024 cats<br>&lt;7&gt;[1.0, init] [    4.130011] SELinux:  92 classes, 11631 rules<br>&lt;6&gt;[1.0, init] [    4.136409] SELinux:  Permission transition in class filesystem not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136489] SELinux:  Permission swapon in class file not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136552] SELinux:  Permission swapon in class dir not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136618] SELinux:  Permission swapon in class lnk_file not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136668] SELinux:  Permission swapon in class chr_file not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136718] SELinux:  Permission swapon in class blk_file not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136768] SELinux:  Permission swapon in class sock_file not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136816] SELinux:  Permission swapon in class fifo_file not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136884] SELinux:  Permission recv_msg in class socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136911] SELinux:  Permission send_msg in class socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136961] SELinux:  Permission recv_msg in class tcp_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.136988] SELinux:  Permission send_msg in class tcp_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137016] SELinux:  Permission connectto in class tcp_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137042] SELinux:  Permission newconn in class tcp_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137068] SELinux:  Permission acceptfrom in class tcp_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137123] SELinux:  Permission recv_msg in class udp_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137149] SELinux:  Permission send_msg in class udp_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137199] SELinux:  Permission recv_msg in class rawip_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137226] SELinux:  Permission send_msg in class rawip_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137259] SELinux:  Permission tcp_recv in class node not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137284] SELinux:  Permission tcp_send in class node not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137309] SELinux:  Permission udp_recv in class node not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137333] SELinux:  Permission udp_send in class node not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137358] SELinux:  Permission rawip_recv in class node not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137384] SELinux:  Permission rawip_send in class node not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137408] SELinux:  Permission enforce_dest in class node not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137434] SELinux:  Permission dccp_recv in class node not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137458] SELinux:  Permission dccp_send in class node not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137492] SELinux:  Permission tcp_recv in class netif not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137517] SELinux:  Permission tcp_send in class netif not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137542] SELinux:  Permission udp_recv in class netif not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137566] SELinux:  Permission udp_send in class netif not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137591] SELinux:  Permission rawip_recv in class netif not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137616] SELinux:  Permission rawip_send in class netif not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137641] SELinux:  Permission dccp_recv in class netif not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137666] SELinux:  Permission dccp_send in class netif not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137714] SELinux:  Permission recv_msg in class netlink_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137741] SELinux:  Permission send_msg in class netlink_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137788] SELinux:  Permission recv_msg in class packet_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137814] SELinux:  Permission send_msg in class packet_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137860] SELinux:  Permission recv_msg in class key_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.137887] SELinux:  Permission send_msg in class key_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138002] SELinux:  Permission recv_msg in class unix_stream_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138033] SELinux:  Permission send_msg in class unix_stream_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138065] SELinux:  Permission newconn in class unix_stream_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138093] SELinux:  Permission acceptfrom in class unix_stream_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138140] SELinux:  Permission recv_msg in class unix_dgram_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138167] SELinux:  Permission send_msg in class unix_dgram_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138270] SELinux:  Permission recv_msg in class netlink_route_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138298] SELinux:  Permission send_msg in class netlink_route_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138333] SELinux:  Class netlink_firewall_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138377] SELinux:  Permission recv_msg in class netlink_tcpdiag_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138405] SELinux:  Permission send_msg in class netlink_tcpdiag_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138459] SELinux:  Permission recv_msg in class netlink_nflog_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138487] SELinux:  Permission send_msg in class netlink_nflog_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138535] SELinux:  Permission recv_msg in class netlink_xfrm_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138562] SELinux:  Permission send_msg in class netlink_xfrm_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138614] SELinux:  Permission recv_msg in class netlink_selinux_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138642] SELinux:  Permission send_msg in class netlink_selinux_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138689] SELinux:  Permission recv_msg in class netlink_audit_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138716] SELinux:  Permission send_msg in class netlink_audit_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138760] SELinux:  Class netlink_ip6fw_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138804] SELinux:  Permission recv_msg in class netlink_dnrt_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138831] SELinux:  Permission send_msg in class netlink_dnrt_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138890] SELinux:  Permission recv_msg in class netlink_kobject_uevent_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138919] SELinux:  Permission send_msg in class netlink_kobject_uevent_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138968] SELinux:  Permission recv_msg in class appletalk_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.138994] SELinux:  Permission send_msg in class appletalk_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.139066] SELinux:  Permission recv_msg in class dccp_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.139093] SELinux:  Permission send_msg in class dccp_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.139165] SELinux:  Permission recv_msg in class tun_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.139191] SELinux:  Permission send_msg in class tun_socket not defined in policy.<br>&lt;6&gt;[1.0, init] [    4.139219] SELinux: the above unknown classes and permissions will be denied<br>&lt;7&gt;[1.0, init] [    4.139332] SELinux:  Completing initialization.<br>&lt;7&gt;[1.0, init] [    4.139354] SELinux:  Setting up existing superblocks.<br>&lt;7&gt;[1.0, init] [    4.139446] SELinux: initialized (dev sysfs, type sysfs), uses genfs_contexts<br>&lt;7&gt;[1.0, init] [    4.139508] SELinux: initialized (dev rootfs, type rootfs), uses genfs_contexts<br>&lt;7&gt;[1.0, init] [    4.141553] SELinux: initialized (dev bdev, type bdev), not configured for labeling<br>&lt;7&gt;[1.0, init] [    4.141640] SELinux: initialized (dev proc, type proc), uses genfs_contexts<br>&lt;7&gt;[1.0, init] [    4.141734] SELinux: initialized (dev tmpfs, type tmpfs), uses transition SIDs<br>&lt;7&gt;[1.0, init] [    4.141843] SELinux: initialized (dev debugfs, type debugfs), uses genfs_contexts<br>&lt;7&gt;[1.0, init] [    4.151691] SELinux: initialized (dev sockfs, type sockfs), uses task SIDs<br>&lt;7&gt;[1.0, init] [    4.151757] SELinux: initialized (dev pipefs, type pipefs), uses task SIDs<br>&lt;7&gt;[1.0, init] [    4.151807] SELinux: initialized (dev anon_inodefs, type anon_inodefs), not configured for labeling<br>&lt;7&gt;[1.0, init] [    4.151864] SELinux: initialized (dev devpts, type devpts), uses transition SIDs<br>&lt;7&gt;[1.0, init] [    4.151953] SELinux: initialized (dev selinuxfs, type selinuxfs), uses genfs_contexts<br>&lt;7&gt;[1.0, init] [    4.152197] SELinux: initialized (dev tmpfs, type tmpfs), uses transition SIDs<br>&lt;7&gt;[1.0, init] [    4.152309] SELinux: initialized (dev sysfs, type sysfs), uses genfs_contexts<br>&lt;5&gt;[1.0, init] [    4.324785] type=1403 audit(1293842172.736:2): policy loaded auid=4294967295 ses=4294967295<br>&lt;6&gt;[1.0, init] [    4.325731] selinux: SELinux: Loaded policy from /sepolicy<br>&lt;6&gt;[1.0, init] [    4.325751] <br>&lt;5&gt;[1.0, init] [    4.327390] type=1404 audit(1293842172.736:3): enforcing=1 old_enforcing=0 auid=4294967295 ses=4294967295<br>&lt;6&gt;[1.0, init] [    4.477327] selinux: SELinux: Loaded file_contexts<br>&lt;6&gt;[1.0, init] [    4.477350] <br>&lt;3&gt;[1.0, init] [    4.479140] selinux: SELinux: Could not set context for /init:  Operation not supported on transport endpoint<br>&lt;3&gt;[1.0, init] [    4.479167] <br>&lt;3&gt;[1.0, init] [    4.479271] init: restorecon failed: Operation not supported on transport endpoint<br>&lt;3&gt;[1.0, init] [    4.479335] init: Security failure...<br>&lt;3&gt;[1.0, init] [    4.479394] init: android::init::panic() invoked. Abort init to trigger kernel panic!<br>&lt;0&gt;[1.0, init] [    4.480145] Kernel panic - not syncing: Attempted to kill init!<br></code></pre></td></tr></table></figure>

<p>从SELinux的日志信息可以看出，内核中的SELinux已经成功启用。但是却在这样一个地方出错，<code>init</code>将其视为严重错误，从而手动触发了panic。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;3&gt;[1.0, init] [    4.479140] selinux: SELinux: Could not set context for /init:  Operation not supported on transport endpoint<br>&lt;3&gt;[1.0, init] [    4.479271] init: restorecon failed: Operation not supported on transport endpoint<br></code></pre></td></tr></table></figure>

<p>带着疑问，我以上述内核日志文本为关键词检索谷歌，在NSA的Bug Tracker中找到了答案。日志中的操作是为根文件系统（rootfs）下的文件设置SELinux上下文，但是该操作并未被内核支持。[^REF: rootfs@NSA_tracker][^REF: rootfs@Android_repo]为此，NSA提供了一个官方补丁，早在2013年9月27日就已应用到Android官方的内核源码当中。根据本地<code>git diff</code>整理出的补丁如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span><br><span class="hljs-comment">index 20219ef54..5e279cdc9 100644</span><br><span class="hljs-comment">--- a/security/selinux/hooks.c</span><br><span class="hljs-comment">+++ b/security/selinux/hooks.c</span><br><span class="hljs-meta">@@ -407,6 +407,13 @@</span> static int sb_finish_set_opts(struct super_block *sb)<br>        if (strncmp(sb-&gt;s_type-&gt;name, &quot;sysfs&quot;, sizeof(&quot;sysfs&quot;)) == 0)<br>                sbsec-&gt;flags |= SE_SBLABELSUPP;<br><br><span class="hljs-addition">+       /*</span><br><span class="hljs-addition">+        * Special handling for rootfs. Is genfs but supports</span><br><span class="hljs-addition">+        * setting SELinux context on in-core inodes.</span><br><span class="hljs-addition">+        */</span><br><span class="hljs-addition">+       if (strncmp(sb-&gt;s_type-&gt;name, &quot;rootfs&quot;, sizeof(&quot;rootfs&quot;)) == 0)</span><br><span class="hljs-addition">+               sbsec-&gt;flags |= SE_SBLABELSUPP;</span><br><span class="hljs-addition">+</span><br>        /* Initialize the root inode. */<br>        rc = inode_doinit_with_dentry(root_inode, root);<br></code></pre></td></tr></table></figure>

<p>应用该补丁后，调试工作又前进了一步。</p>
<h4 id="（2）禁用request-module-调用，避免不必要的内核日志"><a href="#（2）禁用request-module-调用，避免不必要的内核日志" class="headerlink" title="（2）禁用request_module()调用，避免不必要的内核日志"></a>（2）禁用<code>request_module()</code>调用，避免不必要的内核日志</h4><p>下一次panic时，<code>init</code>得以继续往前走，并开启了它的第二阶段进程（second stage）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;5&gt;[1.0, init] [    4.318479] type=1403 audit(1293861906.736:2): policy loaded auid=4294967295 ses=4294967295<br>&lt;6&gt;[1.0, init] [    4.319440] selinux: SELinux: Loaded policy from /sepolicy<br>&lt;6&gt;[1.0, init] [    4.319461] <br>&lt;5&gt;[1.0, init] [    4.321111] type=1404 audit(1293861906.736:3): enforcing=1 old_enforcing=0 auid=4294967295 ses=4294967295<br>&lt;6&gt;[1.0, init] [    4.470829] selinux: SELinux: Loaded file_contexts<br>&lt;6&gt;[1.0, init] [    4.470852] <br>&lt;5&gt;[1.1, init] [    4.476162] type=1400 audit(1293861906.893:4): avc:  denied  &#123; module_request &#125; for  pid=1 comm=&quot;init&quot; kmod=&quot;personality-8&quot; scontext=u:r:init:s0 tcontext=u:r:kernel:s0 tclass=system<br>&lt;6&gt;[1.1, init] [    4.479814] init: init second stage started!<br>&lt;6&gt;[1.1, init] [    4.497218] init: Using Android DT directory /proc/device-tree/firmware/android/<br>&lt;6&gt;[1.1, init] [    4.509308] selinux: SELinux: Loaded file_contexts<br>&lt;6&gt;[1.1, init] [    4.509331] <br>&lt;6&gt;[1.1, init] [    4.511850] selinux: SELinux: Loaded property_contexts from /plat_property_contexts &amp; /nonplat_property_contexts.<br>&lt;6&gt;[1.1, init] [    4.511877] <br>&lt;6&gt;[1.1, init] [    4.511955] init: Running restorecon...<br>&lt;3&gt;[1.1, init] [    4.524907] selinux: SELinux:  Could not stat /dev/block: No such file or directory.<br>&lt;3&gt;[1.1, init] [    4.524935] <br>&lt;1&gt;[1.1, init] [    4.525963] Unable to handle kernel paging request at virtual address fffffff0<br></code></pre></td></tr></table></figure>

<p>然而好景不长，再次面临崩溃。为了分析原因，笔者再次观察日志，留意到了这一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;5&gt;[1.1, init] [    4.476162] type=1400 audit(1293861906.893:4): avc:  denied  &#123; module_request &#125; for  pid=1 comm=&quot;init&quot; kmod=&quot;personality-8&quot; scontext=u:r:init:s0 tcontext=u:r:kernel:s0 tclass=system<br></code></pre></td></tr></table></figure>

<p>这是SELinux阻止某个操作时的提示。有可能是因为这个操作被阻止，导致这一次再度崩溃。再次就此问题查询谷歌，在NSA Bug Tracker中亦可发现这也是NSA早已解决的问题。[^REF: request_module@NSA_tracker]对于该问题，NSA是这样分析的：</p>
<blockquote>
<p>With Android M, Android environments use a separate execution domain for 32bit processes. See: <a target="_blank" rel="noopener" href="https://android-review.googlesource.com/#/c/122131/">https://android-review.googlesource.com/#/c/122131/</a></p>
<p>This results in systems that use kernel modules to see selinux  audit noise like:<br><code>type=1400 audit(28.989:15): avc: denied &#123; module_request &#125; for pid=1622 comm=&quot;app_process32&quot; kmod=&quot;personality-8&quot; scontext=u:r:zygote:s0 tcontext=u:r:kernel:s0 tclass=system</code></p>
<p>While using kernel modules is unadvised, some systems do require  them.</p>
<p>Thus to avoid developers adding sepolicy exceptions to allow for  request_module calls, this patch disables the logic which tries to call request_module for the 32bit personality (ie: personality-8), which doesn’t actually exist.[^REF: request_module@Android_repo]</p>
</blockquote>
<p>根据本地<code>git diff</code>整理出的补丁如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/kernel/exec_domain.c b/kernel/exec_domain.c</span><br><span class="hljs-comment">index 0dbeae374..36cc21da4 100644</span><br><span class="hljs-comment">--- a/kernel/exec_domain.c</span><br><span class="hljs-comment">+++ b/kernel/exec_domain.c</span><br><span class="hljs-meta">@@ -68,7 +68,14 @@</span> lookup_exec_domain(unsigned int personality)<br>                                goto out;<br>        &#125;<br><br><span class="hljs-deletion">-#ifdef CONFIG_MODULES</span><br><span class="hljs-addition">+/*</span><br><span class="hljs-addition">+ * Disable the request_module here to avoid trying to</span><br><span class="hljs-addition">+ * load the personality-8 module, which  doesn&#x27;t exist,</span><br><span class="hljs-addition">+ * and results in selinux audit noise.</span><br><span class="hljs-addition">+ * Disabling this here avoids folks adding module_request</span><br><span class="hljs-addition">+ * to their sepolicy, which is maybe too generous</span><br><span class="hljs-addition">+ */</span><br><span class="hljs-addition">+#if 0</span><br>        read_unlock(&amp;exec_domains_lock);<br>        request_module(&quot;personality-%d&quot;, pers);<br>        read_lock(&amp;exec_domains_lock);<br></code></pre></td></tr></table></figure>

<p>应用补丁后，那一行不再输出，但<code>init</code>仍然在同样的地方发生崩溃。说明<code>init</code>的崩溃与本补丁要解决的问题并无任何关联。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="六、尚待完成的任务"><a href="#六、尚待完成的任务" class="headerlink" title="六、尚待完成的任务"></a>六、尚待完成的任务</h2><h2 id="七、总结与体会"><a href="#七、总结与体会" class="headerlink" title="七、总结与体会"></a>七、总结与体会</h2><p>[^Ref_HD2]: 相比之下，年代更为久远的HTC旗舰手机HD2（2009年推出，预装Windows Mobile 6.5操作系统）则长期受开发者青睐，先后有多个新版本Android系统得以在该设备上运行。<br>[^stopped_support]: 现已停止支持，EMUI官方网站（<a target="_blank" rel="noopener" href="http://www.emui.com)已经不再提供任何下载./">www.emui.com）已经不再提供任何下载。</a><br>[^android_website_in_China]: 谷歌已在中国大陆上线该站点，地址为：source.android.google.cn。<br>[^how_to_disable_them]: 通常的做法为删除，或将代码标为注释。<br>[^why_prune]: 精简的原因是<code>boot</code>分区有大小限制，容量仅为9MB。<br>[^quora]: TODO: <strong>Quora。链接在Chrome书签里！</strong><br>[^unavailable_kernel_debug]: 当然也可以使用串口调试。但诚如前文所述，该方法对于非开发环境而言不现实。<br>[^grep_arguments]: 参数<code>-r</code>表示递归检索目录下的所有文件，<code>-i</code>表示忽略大小写， <code>-n</code>表示显示行号。<br>[^grep_arguments_2]: 参数<code>-l</code>表示只输出符合检索条件的文件名，而不显示它们的匹配之处。<br>[^printk]: Linux内核使用<code>printk()</code>向内核日志中输出信息。用法与<code>printf()</code>相同，但一般会在调用时加入<code>KERN_xxxx</code>宏以标明日志的轻重缓急程度。定义见内核源码目录<code>include/linux/printk.h</code>。<br>[^follow_my_collections]: 根据笔者拥有的早期内核源码判断之。笔者拥有一套Freescale i.mx53的内核源码，其版本即为<code>2.6.35.3</code>。<br>[^REF: rootfs@NSA_tracker]: <code>reference-&gt; A programmer&#39;s same issue on NSA&#39;s bug tracker: http://seandroid-list.tycho.nsa.narkive.com/D3qnO4XY/restorecon-init-fail-in-the-init-cpp-file</code><br>[^REF: rootfs@Android_repo]: <code>reference-&gt; NSA&#39;s kernel patch: https://android-review.googlesource.com/c/kernel/common/+/58360/1</code><br>[^REF: request_module@Android_repo]: <code>reference-&gt; NSA&#39;s kernel patch: https://android-review.googlesource.com/c/kernel/common/+/183036</code><br>[^REF: request_module@NSA_tracker]: <code>reference-&gt; A programmer&#39;s blame on NSA&#39;s bug tracker: http://seandroid-list.tycho.nsa.narkive.com/ep7xOE8K/kernel-module-request-personality-8</code><br>[^another_highest_poldb_ver]: 另一个同为<code>30</code>的PolicyDB版本<code>POLICYDB_VERSION_XEN_DEVICETREE</code>并不适用于一般的Linux环境。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/09/01/Struggle_with_Linux/Ubuntu-18-04-安装搜狗输入法折腾记/" title="Ubuntu 18.04安装搜狗输入法折腾记">
                    Ubuntu 18.04安装搜狗输入法折腾记
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-09-01
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/Linux/">Linux</a></li>
                            
                        
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>搜狗输入法是老牌的中文输入法，它的易用性、海量词库和强悍的云输入一直是广大国人提升输入效率的利器，可谓“码字必备”。PC端上，先前官方开发的是Windows和Mac OS版本，并没有Linux版本。直到后来，Linux系统在国内使用率大增（一切从广大程序猿开始～），搜狗官方开始与优麒麟团队合作，终于让广大Linux用户可以愉快地码字了。</p>
<p>对于Ubuntu用户来说，优麒麟团队的参与，意味着如果你使用Ubuntu Kyrin等由优麒麟团队定制开发的Linux发行版，就可以直接双击搜狗输入法的Deb安装包，开箱即用了。但是，如果你使用原汁原味、不含任何优化的Ubuntu原生版本，尤其是Ubuntu 18.04这样彻底颠覆以往版本的Ubuntu原生版，那就没那么简单了。</p>
<p>笔者的Ubuntu Kirin 16.04更新程序抽风，导致原本更新的18.04无法进入桌面，黑屏不断循环。但是这可是我的生产力系统呀，我得马上修好，遂格盘重装18.04原生版之。后来，笔者习惯性地安装了搜狗输入法官网的Deb包，结果搜狗输入法一直没有预期出现。</p>
<p>这才意识到，原生版的Ubuntu并没有满足搜狗输入法运行的各种条件。笔者摸着石头过河，硬是好好折腾了一番，终于得以在简书上畅快地用搜狗输入法，写下这篇大快人心的经验啦。</p>
        </div>
        
            
                <a href="/2018/09/01/Struggle_with_Linux/Ubuntu-18-04-安装搜狗输入法折腾记/" class="more-link">阅读更多...</a>
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2018/03/18/SDL1/SDL学习笔记（一）：初探/" title="【未完成】SDL学习笔记（一）：初探">
                    【未完成】SDL学习笔记（一）：初探
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2018-03-18
            </li>
            

            
                
                <li class="article-category">
                    <ol class="category-list cl">
                        <i class="fa fa-folder-o"></i>
                        
                            
                            <li><a href="/categories/SDL/">SDL</a></li>
                            
                        
                    </ol>
                </li>
                
            


        </ul>
        <div class="article-description">
            
            <p>SDL（Simple Directmedia Layer）库是一套可跨平台的图形开发库，使用它开发的应用程序可以直接在各种系统中渲染出界面，甚至还可以在任天堂Switch上运行（著名的文件管理器<a target="_blank" rel="noopener" href="https://github.com/joel16/NX-Shell">NX-Shell</a>就是用SDL来绘制界面的）。手上有台Switch的我，也想跃跃欲试。</p>
        </div>
        
            
                <a href="/2018/03/18/SDL1/SDL学习笔记（一）：初探/" class="more-link">阅读更多...</a>
            
        
        
    </div>
</article>

        
        <ul class="pagination clear">
    <a class="extend prev" rel="prev" href="/archives/page/3/">上一页</a><span class="space">&hellip;</span><a class="page-number" href="/archives/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/archives/page/5/">5</a><a class="extend next" rel="next" href="/archives/page/5/">下一页</a>
</ul>
    </section>
    
<section class="tool-area">

    <div class="toolbar">
        

        
        <div class="widget-post widget" style="order: 1 ">
            <h2 class="widget-title"><i class="fa fa-file-text"></i> 近期文章</h2>
            <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/04/26/BlackMacOS/Tianocore_On_USB_Drive/">U盘安装Tianocore，让BIOS老机器跑上UEFI</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/12/Git/Git_Sync_Commits/">GitHub：如何只提交/应用指定commit（Pull Request，或更新本地代码）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/09/Programming_Tips/Makefile_%E8%B8%A9%E5%9D%91%E8%AE%B0/">Makefile 编写时的几个大坑和技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/11/Struggle_with_Linux/%E8%A7%A3%E5%86%B3Linux%E4%B8%8Bzip%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/">解决Linux下ZIP压缩包乱码的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/09/Linux_Audio_Production/Make_Your_ArchLinux_An_Audio_Workstation_03.md/">把Arch Linux打造成音乐工作站（三）：使用Windows下的VST插件</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/08/Linux_Audio_Production/Make_Your_ArchLinux_An_Audio_Workstation_01/">把Arch Linux打造成音乐工作站（一）：安装与配置JACK</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/25/Linux_Audio_Production/Make_Your_ArchLinux_An_Audio_Workstation_02/">把Arch Linux打造成音乐工作站（二）：安装WineASIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/23/Struggle_with_Linux/%E7%BB%99RIME%E4%B8%AD%E5%B7%9E%E9%9F%B5%E6%B7%BB%E5%8A%A0%E8%AF%8D%E5%BA%93/">Arch Linux下给RIME中州韵添加词库</a></li></ul>
        </div>
        

        
        <div class="widget-tags widget" style="order: 2 ">
            <h2 class="widget-title"><i class="fa fa-tags"></i> 标签</h2>
            <a href="/tags/ASIO/" style="font-size: 10px;">ASIO</a> <a href="/tags/Android-%E9%80%82%E9%85%8D/" style="font-size: 10px;">Android 适配</a> <a href="/tags/Android-%E9%80%82%E9%85%8D%E6%95%99%E7%A8%8B/" style="font-size: 12.5px;">Android 适配教程</a> <a href="/tags/Android-%E9%80%82%E9%85%8D%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">Android 适配笔记</a> <a href="/tags/Apache2/" style="font-size: 10px;">Apache2</a> <a href="/tags/Arch-Linux/" style="font-size: 12.5px;">Arch Linux</a> <a href="/tags/BIOS/" style="font-size: 10px;">BIOS</a> <a href="/tags/BusyBox/" style="font-size: 10px;">BusyBox</a> <a href="/tags/Cherry-Pick/" style="font-size: 10px;">Cherry Pick</a> <a href="/tags/Debian/" style="font-size: 10px;">Debian</a> <a href="/tags/Deepin/" style="font-size: 17.5px;">Deepin</a> <a href="/tags/Foobar2000/" style="font-size: 10px;">Foobar2000</a> <a href="/tags/GitHub/" style="font-size: 10px;">GitHub</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Hexo%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">Hexo插件</a> <a href="/tags/IPv6/" style="font-size: 10px;">IPv6</a> <a href="/tags/JACK/" style="font-size: 10px;">JACK</a> <a href="/tags/KDE/" style="font-size: 10px;">KDE</a> <a href="/tags/Linux/" style="font-size: 17.5px;">Linux</a> <a href="/tags/Linux-%E5%AE%89%E8%A3%85/" style="font-size: 10px;">Linux 安装</a> <a href="/tags/MBR/" style="font-size: 10px;">MBR</a> <a href="/tags/Mac-OS/" style="font-size: 10px;">Mac OS</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/NAS/" style="font-size: 10px;">NAS</a> <a href="/tags/OMV/" style="font-size: 10px;">OMV</a> <a href="/tags/OpenSUSE/" style="font-size: 10px;">OpenSUSE</a> <a href="/tags/OpenWrt/" style="font-size: 10px;">OpenWrt</a> <a href="/tags/Openmediavault/" style="font-size: 10px;">Openmediavault</a> <a href="/tags/PHP/" style="font-size: 10px;">PHP</a> <a href="/tags/Pull-Request/" style="font-size: 10px;">Pull Request</a> <a href="/tags/PyAudio/" style="font-size: 10px;">PyAudio</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/RIME/" style="font-size: 10px;">RIME</a> <a href="/tags/SDL/" style="font-size: 10px;">SDL</a> <a href="/tags/Snap/" style="font-size: 10px;">Snap</a> <a href="/tags/Snapd/" style="font-size: 10px;">Snapd</a> <a href="/tags/TWRP/" style="font-size: 12.5px;">TWRP</a> <a href="/tags/UEFI/" style="font-size: 10px;">UEFI</a> <a href="/tags/Ubuntu/" style="font-size: 12.5px;">Ubuntu</a> <a href="/tags/VSCode/" style="font-size: 10px;">VSCode</a> <a href="/tags/VST/" style="font-size: 10px;">VST</a> <a href="/tags/Wine/" style="font-size: 12.5px;">Wine</a> <a href="/tags/ZIP/" style="font-size: 10px;">ZIP</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/%E4%B9%B1%E7%A0%81/" style="font-size: 10px;">乱码</a> <a href="/tags/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">使用技巧</a> <a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 10px;">内核</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E5%8C%85/" style="font-size: 10px;">压缩包</a> <a href="/tags/%E5%9E%82%E7%9B%B4%E5%90%8C%E6%AD%A5/" style="font-size: 10px;">垂直同步</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">学习笔记</a>
        </div>
        

        
        <div class="widget-categories widget" style="order: 3 ">
            <h2 class="widget-title"><i class="fa fa-folder-open"></i> 分类</h2>
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/%E9%80%82%E9%85%8D/">适配</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/%E9%80%82%E9%85%8D/%E6%95%99%E7%A8%8B/">教程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/%E9%80%82%E9%85%8D/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">7</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/%E6%8F%92%E4%BB%B6/">插件</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Arch-Linux/">Arch Linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Deepin/">Deepin</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/OpenSUSE/">OpenSUSE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Ubuntu/">Ubuntu</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Ubuntu/Snap/">Snap</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/npm/">npm</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">安装配置</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDL/">SDL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Switch/">Switch</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Switch/%E5%BC%80%E5%8F%91/">开发</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mac-OS/">Mac OS</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mac-OS/%E9%BB%91%E8%8B%B9%E6%9E%9C/">黑苹果</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UEFI/">UEFI</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%A9%E8%BD%ACNAS/">玩转NAS</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%A9%E8%BD%ACNAS/Openmediavault/">Openmediavault</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%B5%E8%84%91%E7%BB%B4%E4%BF%AE/">电脑维修</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%B5%E8%84%91%E7%BB%B4%E4%BF%AE/%E6%95%85%E9%9A%9C%E8%A7%A3%E5%86%B3/">故障解决</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/">编程经验</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/Makefile/">Makefile</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8/">路由器</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87%E6%8A%A5%E5%91%8A/">论文报告</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87%E6%8A%A5%E5%91%8A/%E5%8F%8C%E5%AD%A6%E4%BD%8D%E8%AE%BA%E6%96%87/">双学位论文</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90%E5%88%B6%E4%BD%9C/">音乐制作</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90%E5%88%B6%E4%BD%9C/Linux%E4%B8%8B%E5%81%9A%E9%9F%B3%E4%B9%90/">Linux下做音乐</a><span class="category-list-count">3</span></li></ul></li></ul>
        </div>
        

    </div>
</section>
</div>

    
        <footer class="footer">
	<p class="footer-intro">
		
		@2022 爱拼安小匠的技术博客.
	</p>
	<p class="footer-intro">
			Powered By <a href="https://hexo.io/zh-cn/" target="_blank">hexo</a>
			theme <a href="https://github.com/iengu/hexo-theme-mokusei" target="_blank">mokusei</a> by <a href="https://www.iengu.com" target="blank">iengu</a>
	</p>
</footer>




        <div class="extend-tools" id="extend-tools" style="display: none;">
    <ul>
        <li class="tools-returnTop" title="返回顶部"><i class="fa fa-angle-double-up"></i></li>
    </ul>
</div>

	</div>

	
<script src="/js/org/jquery.min.js"></script>

    
<script src="/js/extend.js"></script>

</body>
</html>